// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {});
};

/**
 * OAuth2 JWT Bearer Grant Type Issuer Trusted JSON Web Key
 */
export type TrustedOAuth2JwtGrantJsonWebKey = {
  /**
   * The "key_id" is key unique identifier (same as kid header in jws/jwt).
   */
  kid?: string;
  /**
   * The "set" is basically a name for a group(set) of keys. Will be the same as "issuer" in grant.
   */
  set?: string;
};

/**
 * OAuth2 JWT Bearer Grant Type Issuer Trust Relationships
 */
export type TrustedOAuth2JwtGrantIssuers = Array<TrustedOAuth2JwtGrantIssuer>;

/**
 * OAuth2 JWT Bearer Grant Type Issuer Trust Relationship
 */
export type TrustedOAuth2JwtGrantIssuer = {
  /**
   * The "allow_any_subject" indicates that the issuer is allowed to have any principal as the subject of the JWT.
   */
  allow_any_subject?: boolean;
  /**
   * The "created_at" indicates, when grant was created.
   */
  created_at?: string;
  /**
   * The "expires_at" indicates, when grant will expire, so we will reject assertion from "issuer" targeting "subject".
   */
  expires_at?: string;
  id?: string;
  /**
   * The "issuer" identifies the principal that issued the JWT assertion (same as "iss" claim in JWT).
   */
  issuer?: string;
  public_key?: TrustedOAuth2JwtGrantJsonWebKey;
  /**
   * The "scope" contains list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749])
   */
  scope?: Array<string>;
  /**
   * The "subject" identifies the principal that is the subject of the JWT.
   */
  subject?: string;
};

/**
 * Trust OAuth2 JWT Bearer Grant Type Issuer Request Body
 */
export type TrustOAuth2JwtGrantIssuer = {
  /**
   * The "allow_any_subject" indicates that the issuer is allowed to have any principal as the subject of the JWT.
   */
  allow_any_subject?: boolean;
  /**
   * The "expires_at" indicates, when grant will expire, so we will reject assertion from "issuer" targeting "subject".
   */
  expires_at: string;
  /**
   * The "issuer" identifies the principal that issued the JWT assertion (same as "iss" claim in JWT).
   */
  issuer: string;
  jwk: JsonWebKey;
  /**
   * The "scope" contains list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749])
   */
  scope: Array<string>;
  /**
   * The "subject" identifies the principal that is the subject of the JWT.
   */
  subject?: string;
};

export type JsonWebKey = {
  /**
   * The "alg" (algorithm) parameter identifies the algorithm intended for
   * use with the key.  The values used should either be registered in the
   * IANA "JSON Web Signature and Encryption Algorithms" registry
   * established by [JWA] or be a value that contains a Collision-
   * Resistant Name.
   */
  alg: string;
  crv?: string;
  d?: string;
  dp?: string;
  dq?: string;
  e?: string;
  k?: string;
  /**
   * The "kid" (key ID) parameter is used to match a specific key.  This
   * is used, for instance, to choose among a set of keys within a JWK Set
   * during key rollover.  The structure of the "kid" value is
   * unspecified.  When "kid" values are used within a JWK Set, different
   * keys within the JWK Set SHOULD use distinct "kid" values.  (One
   * example in which different keys might use the same "kid" value is if
   * they have different "kty" (key type) values but are considered to be
   * equivalent alternatives by the application using them.)  The "kid"
   * value is a case-sensitive string.
   */
  kid: string;
  /**
   * The "kty" (key type) parameter identifies the cryptographic algorithm
   * family used with the key, such as "RSA" or "EC". "kty" values should
   * either be registered in the IANA "JSON Web Key Types" registry
   * established by [JWA] or be a value that contains a Collision-
   * Resistant Name.  The "kty" value is a case-sensitive string.
   */
  kty: string;
  n?: string;
  p?: string;
  q?: string;
  qi?: string;
  /**
   * Use ("public key use") identifies the intended use of
   * the public key. The "use" parameter is employed to indicate whether
   * a public key is used for encrypting data or verifying the signature
   * on data. Values are commonly "sig" (signature) or "enc" (encryption).
   */
  use: string;
  x?: string;
  /**
   * The "x5c" (X.509 certificate chain) parameter contains a chain of one
   * or more PKIX certificates [RFC5280].  The certificate chain is
   * represented as a JSON array of certificate value strings.  Each
   * string in the array is a base64-encoded (Section 4 of [RFC4648] --
   * not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value.
   * The PKIX certificate containing the key value MUST be the first
   * certificate.
   */
  x5c?: Array<string>;
  y?: string;
};

/**
 * The request payload used to accept a login or consent request.
 */
export type RejectOAuth2Request = {
  /**
   * The error should follow the OAuth2 error format (e.g. `invalid_request`, `login_required`).
   *
   * Defaults to `request_denied`.
   */
  error?: string;
  /**
   * Debug contains information to help resolve the problem as a developer. Usually not exposed
   * to the public but only in the server logs.
   */
  error_debug?: string;
  /**
   * Description of the error in a human readable format.
   */
  error_description?: string;
  /**
   * Hint to help resolve the error.
   */
  error_hint?: string;
  /**
   * Represents the HTTP status code of the error (e.g. 401 or 403)
   *
   * Defaults to 400
   */
  status_code?: number;
};

/**
 * OAuth 2.0 Redirect Browser To
 *
 * Contains a redirect URL used to complete a login, consent, or logout request.
 */
export type OAuth2RedirectTo = {
  /**
   * RedirectURL is the URL which you should redirect the user's browser to once the authentication process is completed.
   */
  redirect_to: string;
};

/**
 * Contains information about an ongoing logout request.
 */
export type OAuth2LogoutRequest = {
  /**
   * Challenge is the identifier ("logout challenge") of the logout authentication request. It is used to
   * identify the session.
   */
  challenge?: string;
  client?: OAuth2Client | null;
  expires_at?: NullTime;
  /**
   * RequestURL is the original Logout URL requested.
   */
  request_url?: string;
  requested_at?: NullTime;
  /**
   * RPInitiated is set to true if the request was initiated by a Relying Party (RP), also known as an OAuth 2.0 Client.
   */
  rp_initiated?: boolean;
  /**
   * SessionID is the login session ID that was requested to log out.
   */
  sid?: string;
  /**
   * Subject is the user for whom the logout was request.
   */
  subject?: string;
};

/**
 * NullTime implements sql.NullTime functionality.
 */
export type NullTime = string | null;

/**
 * JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger.
 */
export type JsonRawMessage = unknown;

/**
 * Time duration
 *
 * Specify a time duration in milliseconds, seconds, minutes, hours.
 */
export type NullDuration = string | null;

/**
 * StringSliceJSONFormat represents []string{} which is encoded to/from JSON for SQL storage.
 */
export type StringSliceJsonFormat = Array<string>;

/**
 * OAuth 2.0 Client
 *
 * OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
 * generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
 */
export type OAuth2Client = {
  /**
   * OAuth 2.0 Access Token Strategy
   *
   * AccessTokenStrategy is the strategy used to generate access tokens.
   * Valid options are `jwt` and `opaque`. `jwt` is a bad idea, see https://www.ory.sh/docs/hydra/advanced#json-web-tokens
   * Setting the stragegy here overrides the global setting in `strategies.access_token`.
   */
  access_token_strategy?: string;
  allowed_cors_origins?: StringSliceJsonFormat;
  audience?: StringSliceJsonFormat;
  authorization_code_grant_access_token_lifespan?: NullDuration;
  authorization_code_grant_id_token_lifespan?: NullDuration;
  authorization_code_grant_refresh_token_lifespan?: NullDuration;
  /**
   * OpenID Connect Back-Channel Logout Session Required
   *
   * Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout
   * Token to identify the RP session with the OP when the backchannel_logout_uri is used.
   * If omitted, the default value is false.
   */
  backchannel_logout_session_required?: boolean;
  /**
   * OpenID Connect Back-Channel Logout URI
   *
   * RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
   */
  backchannel_logout_uri?: string;
  client_credentials_grant_access_token_lifespan?: NullDuration;
  /**
   * OAuth 2.0 Client ID
   *
   * The ID is immutable. If no ID is provided, a UUID4 will be generated.
   */
  client_id?: string;
  /**
   * OAuth 2.0 Client Name
   *
   * The human-readable name of the client to be presented to the
   * end-user during authorization.
   */
  client_name?: string;
  /**
   * OAuth 2.0 Client Secret
   *
   * The secret will be included in the create request as cleartext, and then
   * never again. The secret is kept in hashed format and is not recoverable once lost.
   */
  client_secret?: string;
  /**
   * OAuth 2.0 Client Secret Expires At
   *
   * The field is currently not supported and its value is always 0.
   */
  client_secret_expires_at?: number;
  /**
   * OAuth 2.0 Client URI
   *
   * ClientURI is a URL string of a web page providing information about the client.
   * If present, the server SHOULD display this URL to the end-user in
   * a clickable fashion.
   */
  client_uri?: string;
  contacts?: StringSliceJsonFormat;
  /**
   * OAuth 2.0 Client Creation Date
   *
   * CreatedAt returns the timestamp of the client's creation.
   */
  created_at?: string;
  /**
   * OpenID Connect Front-Channel Logout Session Required
   *
   * Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be
   * included to identify the RP session with the OP when the frontchannel_logout_uri is used.
   * If omitted, the default value is false.
   */
  frontchannel_logout_session_required?: boolean;
  /**
   * OpenID Connect Front-Channel Logout URI
   *
   * RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query
   * parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the
   * request and to determine which of the potentially multiple sessions is to be logged out; if either is
   * included, both MUST be.
   */
  frontchannel_logout_uri?: string;
  grant_types?: StringSliceJsonFormat;
  implicit_grant_access_token_lifespan?: NullDuration;
  implicit_grant_id_token_lifespan?: NullDuration;
  /**
   * OAuth 2.0 Client JSON Web Key Set
   *
   * Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as
   * the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter
   * is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for
   * instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client
   * can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation
   * (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks
   * parameters MUST NOT be used together.
   */
  jwks?: unknown;
  /**
   * OAuth 2.0 Client JSON Web Key Set URL
   *
   * URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains
   * the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the
   * Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing
   * and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced
   * JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both
   * signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used
   * to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST
   * match those in the certificate.
   */
  jwks_uri?: string;
  jwt_bearer_grant_access_token_lifespan?: NullDuration;
  /**
   * OAuth 2.0 Client Logo URI
   *
   * A URL string referencing the client's logo.
   */
  logo_uri?: string;
  metadata?: JsonRawMessage;
  /**
   * OAuth 2.0 Client Owner
   *
   * Owner is a string identifying the owner of the OAuth 2.0 Client.
   */
  owner?: string;
  /**
   * OAuth 2.0 Client Policy URI
   *
   * PolicyURI is a URL string that points to a human-readable privacy policy document
   * that describes how the deployment organization collects, uses,
   * retains, and discloses personal data.
   */
  policy_uri?: string;
  post_logout_redirect_uris?: StringSliceJsonFormat;
  redirect_uris?: StringSliceJsonFormat;
  refresh_token_grant_access_token_lifespan?: NullDuration;
  refresh_token_grant_id_token_lifespan?: NullDuration;
  refresh_token_grant_refresh_token_lifespan?: NullDuration;
  /**
   * OpenID Connect Dynamic Client Registration Access Token
   *
   * RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client
   * using Dynamic Client Registration.
   */
  registration_access_token?: string;
  /**
   * OpenID Connect Dynamic Client Registration URL
   *
   * RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
   */
  registration_client_uri?: string;
  /**
   * OpenID Connect Request Object Signing Algorithm
   *
   * JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects
   * from this Client MUST be rejected, if not signed with this algorithm.
   */
  request_object_signing_alg?: string;
  request_uris?: StringSliceJsonFormat;
  response_types?: StringSliceJsonFormat;
  /**
   * OAuth 2.0 Client Scope
   *
   * Scope is a string containing a space-separated list of scope values (as
   * described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client
   * can use when requesting access tokens.
   */
  scope?: string;
  /**
   * OpenID Connect Sector Identifier URI
   *
   * URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a
   * file with a single JSON array of redirect_uri values.
   */
  sector_identifier_uri?: string;
  /**
   * SkipConsent skips the consent screen for this client. This field can only
   * be set from the admin API.
   */
  skip_consent?: boolean;
  /**
   * SkipLogoutConsent skips the logout consent screen for this client. This field can only
   * be set from the admin API.
   */
  skip_logout_consent?: boolean | null;
  /**
   * OpenID Connect Subject Type
   *
   * The `subject_types_supported` Discovery parameter contains a
   * list of the supported subject_type values for this server. Valid types include `pairwise` and `public`.
   */
  subject_type?: string;
  /**
   * OAuth 2.0 Token Endpoint Authentication Method
   *
   * Requested Client Authentication method for the Token Endpoint. The options are:
   *
   * `client_secret_basic`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header.
   * `client_secret_post`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body.
   * `private_key_jwt`: Use JSON Web Tokens to authenticate the client.
   * `none`: Used for public clients (native apps, mobile apps) which can not have secrets.
   */
  token_endpoint_auth_method?: string;
  /**
   * OAuth 2.0 Token Endpoint Signing Algorithm
   *
   * Requested Client Authentication signing algorithm for the Token Endpoint.
   */
  token_endpoint_auth_signing_alg?: string;
  /**
   * OAuth 2.0 Client Terms of Service URI
   *
   * A URL string pointing to a human-readable terms of service
   * document for the client that describes a contractual relationship
   * between the end-user and the client that the end-user accepts when
   * authorizing the client.
   */
  tos_uri?: string;
  /**
   * OAuth 2.0 Client Last Update Date
   *
   * UpdatedAt returns the timestamp of the last update.
   */
  updated_at?: string;
  /**
   * OpenID Connect Request Userinfo Signed Response Algorithm
   *
   * JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT
   * [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims
   * as a UTF-8 encoded JSON object using the application/json content-type.
   */
  userinfo_signed_response_alg?: string;
};

/**
 * Contains information on an ongoing login request.
 */
export type OAuth2LoginRequest = {
  /**
   * ID is the identifier ("login challenge") of the login request. It is used to
   * identify the session.
   */
  challenge: string;
  client: OAuth2Client;
  oidc_context?: OAuth2ConsentRequestOpenIdConnectContext;
  /**
   * RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
   * initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
   * might come in handy if you want to deal with additional request parameters.
   */
  request_url: string;
  requested_access_token_audience?: StringSliceJsonFormat;
  requested_scope?: StringSliceJsonFormat;
  /**
   * SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag)
   * this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false)
   * this will be a new random value. This value is used as the "sid" parameter in the ID Token and in OIDC Front-/Back-
   * channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
   */
  session_id?: string;
  /**
   * Skip, if true, implies that the client has requested the same scopes from the same user previously.
   * If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.
   *
   * This feature allows you to update / set session information.
   */
  skip: boolean;
  /**
   * Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope
   * requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type
   * when accepting the login request, or the request will fail.
   */
  subject: string;
};

/**
 * Contains optional information about the OpenID Connect request.
 */
export type OAuth2ConsentRequestOpenIdConnectContext = {
  /**
   * ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request.
   * It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.
   *
   * OpenID Connect defines it as follows:
   * > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values
   * that the Authorization Server is being requested to use for processing this Authentication Request, with the
   * values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication
   * performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a
   * Voluntary Claim by this parameter.
   */
  acr_values?: Array<string>;
  /**
   * Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User.
   * The defined values are:
   * page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode.
   * popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over.
   * touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface.
   * wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a "feature phone" type display.
   *
   * The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.
   */
  display?: string;
  /**
   * IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the
   * End-User's current or past authenticated session with the Client.
   */
  id_token_hint_claims?: {
    [key: string]: unknown;
  };
  /**
   * LoginHint hints about the login identifier the End-User might use to log in (if necessary).
   * This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier)
   * and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a
   * phone number in the format specified for the phone_number Claim. The use of this parameter is optional.
   */
  login_hint?: string;
  /**
   * UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a
   * space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value
   * "fr-CA fr en" represents a preference for French as spoken in Canada, then French (without a region designation),
   * followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested
   * locales are not supported by the OpenID Provider.
   */
  ui_locales?: Array<string>;
};

/**
 * List of OAuth 2.0 Consent Sessions
 */
export type OAuth2ConsentSessions = Array<OAuth2ConsentSession>;

/**
 * Pass session data to a consent request.
 */
export type AcceptOAuth2ConsentRequestSession = {
  /**
   * AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the
   * refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection.
   * If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties
   * can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care!
   */
  access_token?: unknown;
  /**
   * IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable
   * by anyone that has access to the ID Challenge. Use with care!
   */
  id_token?: unknown;
};

/**
 * Contains information on an ongoing consent request.
 */
export type OAuth2ConsentRequest = {
  /**
   * ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
   * to express that, for example, a user authenticated using two factor authentication.
   */
  acr?: string;
  amr?: StringSliceJsonFormat;
  /**
   * ID is the identifier ("authorization challenge") of the consent authorization request. It is used to
   * identify the session.
   */
  challenge: string;
  client?: OAuth2Client;
  context?: JsonRawMessage;
  /**
   * LoginChallenge is the login challenge this consent challenge belongs to. It can be used to associate
   * a login and consent request in the login & consent app.
   */
  login_challenge?: string;
  /**
   * LoginSessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag)
   * this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false)
   * this will be a new random value. This value is used as the "sid" parameter in the ID Token and in OIDC Front-/Back-
   * channel logout. It's value can generally be used to associate consecutive login requests by a certain user.
   */
  login_session_id?: string;
  oidc_context?: OAuth2ConsentRequestOpenIdConnectContext;
  /**
   * RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
   * initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
   * might come in handy if you want to deal with additional request parameters.
   */
  request_url?: string;
  requested_access_token_audience?: StringSliceJsonFormat;
  requested_scope?: StringSliceJsonFormat;
  /**
   * Skip, if true, implies that the client has requested the same scopes from the same user previously.
   * If true, you must not ask the user to grant the requested scopes. You must however either allow or deny the
   * consent request using the usual API call.
   */
  skip?: boolean;
  /**
   * Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope
   * requested by the OAuth 2.0 client.
   */
  subject?: string;
};

/**
 * OAuth 2.0 Consent Session
 *
 * A completed OAuth 2.0 Consent Session.
 */
export type OAuth2ConsentSession = {
  consent_request?: OAuth2ConsentRequest;
  context?: JsonRawMessage;
  expires_at?: {
    access_token?: string;
    authorize_code?: string;
    id_token?: string;
    par_context?: string;
    refresh_token?: string;
  };
  grant_access_token_audience?: StringSliceJsonFormat;
  grant_scope?: StringSliceJsonFormat;
  handled_at?: NullTime;
  /**
   * Remember Consent
   *
   * Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
   * client asks the same user for the same, or a subset of, scope.
   */
  remember?: boolean;
  /**
   * Remember Consent For
   *
   * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
   * authorization will be remembered indefinitely.
   */
  remember_for?: number;
  session?: AcceptOAuth2ConsentRequestSession;
};

/**
 * OAuth 2.0 Client Token Lifespans
 *
 * Lifespans of different token types issued for this OAuth 2.0 Client.
 */
export type OAuth2ClientTokenLifespans = {
  authorization_code_grant_access_token_lifespan?: NullDuration;
  authorization_code_grant_id_token_lifespan?: NullDuration;
  authorization_code_grant_refresh_token_lifespan?: NullDuration;
  client_credentials_grant_access_token_lifespan?: NullDuration;
  implicit_grant_access_token_lifespan?: NullDuration;
  implicit_grant_id_token_lifespan?: NullDuration;
  jwt_bearer_grant_access_token_lifespan?: NullDuration;
  refresh_token_grant_access_token_lifespan?: NullDuration;
  refresh_token_grant_id_token_lifespan?: NullDuration;
  refresh_token_grant_refresh_token_lifespan?: NullDuration;
};

/**
 * JSON Web Key Set
 */
export type JsonWebKeySet = {
  /**
   * List of JSON Web Keys
   *
   * The value of the "keys" parameter is an array of JSON Web Key (JWK)
   * values. By default, the order of the JWK values within the array does
   * not imply an order of preference among them, although applications
   * of JWK Sets can choose to assign a meaning to the order for their
   * purposes, if desired.
   */
  keys?: Array<JsonWebKey>;
};

/**
 * A JSONPatchDocument request
 */
export type JsonPatchDocument = Array<JsonPatch>;

/**
 * A JSONPatch document as defined by RFC 6902
 */
export type JsonPatch = {
  /**
   * This field is used together with operation "move" and uses JSON Pointer notation.
   *
   * Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
   */
  from?: string;
  /**
   * The operation to be performed. One of "add", "remove", "replace", "move", "copy", or "test".
   */
  op: string;
  /**
   * The path to the target path. Uses JSON pointer notation.
   *
   * Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
   */
  path: string;
  /**
   * The value to be used within the operations.
   *
   * Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
   */
  value?: unknown;
};

/**
 * Introspection contains an access token's session data as specified by
 * [IETF RFC 7662](https://tools.ietf.org/html/rfc7662)
 */
export type IntrospectedOAuth2Token = {
  /**
   * Active is a boolean indicator of whether or not the presented token
   * is currently active.  The specifics of a token's "active" state
   * will vary depending on the implementation of the authorization
   * server and the information it keeps about its tokens, but a "true"
   * value return for the "active" property will generally indicate
   * that a given token has been issued by this authorization server,
   * has not been revoked by the resource owner, and is within its
   * given time window of validity (e.g., after its issuance time and
   * before its expiration time).
   */
  active: boolean;
  /**
   * Audience contains a list of the token's intended audiences.
   */
  aud?: Array<string>;
  /**
   * ID is aclient identifier for the OAuth 2.0 client that
   * requested this token.
   */
  client_id?: string;
  /**
   * Expires at is an integer timestamp, measured in the number of seconds
   * since January 1 1970 UTC, indicating when this token will expire.
   */
  exp?: number;
  /**
   * Extra is arbitrary data set by the session.
   */
  ext?: {
    [key: string]: unknown;
  };
  /**
   * Issued at is an integer timestamp, measured in the number of seconds
   * since January 1 1970 UTC, indicating when this token was
   * originally issued.
   */
  iat?: number;
  /**
   * IssuerURL is a string representing the issuer of this token
   */
  iss?: string;
  /**
   * NotBefore is an integer timestamp, measured in the number of seconds
   * since January 1 1970 UTC, indicating when this token is not to be
   * used before.
   */
  nbf?: number;
  /**
   * ObfuscatedSubject is set when the subject identifier algorithm was set to "pairwise" during authorization.
   * It is the `sub` value of the ID Token that was issued.
   */
  obfuscated_subject?: string;
  /**
   * Scope is a JSON string containing a space-separated list of
   * scopes associated with this token.
   */
  scope?: string;
  /**
   * Subject of the token, as defined in JWT [RFC7519].
   * Usually a machine-readable identifier of the resource owner who
   * authorized this token.
   */
  sub?: string;
  /**
   * TokenType is the introspected token's type, typically `Bearer`.
   */
  token_type?: string;
  /**
   * TokenUse is the introspected token's use, for example `access_token` or `refresh_token`.
   */
  token_use?: string;
  /**
   * Username is a human-readable identifier for the resource owner who
   * authorized this token.
   */
  username?: string;
};

/**
 * The health status of the service.
 */
export type HealthStatus = {
  /**
   * Status always contains "ok".
   */
  status?: string;
};

export type GenericError = {
  /**
   * The status code
   */
  code?: number;
  /**
   * Debug information
   *
   * This field is often not exposed to protect against leaking
   * sensitive information.
   */
  debug?: string;
  /**
   * Further error details
   */
  details?: unknown;
  /**
   * The error ID
   *
   * Useful when trying to identify various errors in application logic.
   */
  id?: string;
  /**
   * Error message
   *
   * The error's message.
   */
  message: string;
  /**
   * A human-readable reason for the error
   */
  reason?: string;
  /**
   * The request ID
   *
   * The request ID is often exposed internally in order to trace
   * errors across service architectures. This is often a UUID.
   */
  request?: string;
  /**
   * The status description
   */
  status?: string;
};

/**
 * Error
 */
export type ErrorOAuth2 = {
  /**
   * Error
   */
  error?: string;
  /**
   * Error Debug Information
   *
   * Only available in dev mode.
   */
  error_debug?: string;
  /**
   * Error Description
   */
  error_description?: string;
  /**
   * Error Hint
   *
   * Helps the user identify the error cause.
   */
  error_hint?: string;
  /**
   * HTTP Status Code
   */
  status_code?: number;
};

/**
 * Create JSON Web Key Set Request Body
 */
export type CreateJsonWebKeySet = {
  /**
   * JSON Web Key Algorithm
   *
   * The algorithm to be used for creating the key. Supports `RS256`, `ES256`, `ES512`, `HS512`, and `HS256`.
   */
  alg: string;
  /**
   * JSON Web Key ID
   *
   * The Key ID of the key to be created.
   */
  kid: string;
  /**
   * JSON Web Key Use
   *
   * The "use" (public key use) parameter identifies the intended use of
   * the public key. The "use" parameter is employed to indicate whether
   * a public key is used for encrypting data or verifying the signature
   * on data. Valid values are "enc" and "sig".
   */
  use: string;
};

/**
 * HandledLoginRequest is the request payload used to accept a login request.
 */
export type AcceptOAuth2LoginRequest = {
  /**
   * ACR sets the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
   * to express that, for example, a user authenticated using two factor authentication.
   */
  acr?: string;
  amr?: StringSliceJsonFormat;
  context?: JsonRawMessage;
  /**
   * Extend OAuth2 authentication session lifespan
   *
   * If set to `true`, the OAuth2 authentication cookie lifespan is extended. This is for example useful if you want the user to be able to use `prompt=none` continuously.
   *
   * This value can only be set to `true` if the user has an authentication, which is the case if the `skip` value is `true`.
   */
  extend_session_lifespan?: boolean;
  /**
   * ForceSubjectIdentifier forces the "pairwise" user ID of the end-user that authenticated. The "pairwise" user ID refers to the
   * (Pairwise Identifier Algorithm)[http://openid.net/specs/openid-connect-core-1_0.html#PairwiseAlg] of the OpenID
   * Connect specification. It allows you to set an obfuscated subject ("user") identifier that is unique to the client.
   *
   * Please note that this changes the user ID on endpoint /userinfo and sub claim of the ID Token. It does not change the
   * sub claim in the OAuth 2.0 Introspection.
   *
   * Per default, ORY Hydra handles this value with its own algorithm. In case you want to set this yourself
   * you can use this field. Please note that setting this field has no effect if `pairwise` is not configured in
   * ORY Hydra or the OAuth 2.0 Client does not expect a pairwise identifier (set via `subject_type` key in the client's
   * configuration).
   *
   * Please also be aware that ORY Hydra is unable to properly compute this value during authentication. This implies
   * that you have to compute this value on every authentication process (probably depending on the client ID or some
   * other unique value).
   *
   * If you fail to compute the proper value, then authentication processes which have id_token_hint set might fail.
   */
  force_subject_identifier?: string;
  /**
   * IdentityProviderSessionID is the session ID of the end-user that authenticated.
   * If specified, we will use this value to propagate the logout.
   */
  identity_provider_session_id?: string;
  /**
   * Remember, if set to true, tells ORY Hydra to remember this user by telling the user agent (browser) to store
   * a cookie with authentication data. If the same user performs another OAuth 2.0 Authorization Request, he/she
   * will not be asked to log in again.
   */
  remember?: boolean;
  /**
   * RememberFor sets how long the authentication should be remembered for in seconds. If set to `0`, the
   * authorization will be remembered for the duration of the browser session (using a session cookie).
   */
  remember_for?: number;
  /**
   * Subject is the user ID of the end-user that authenticated.
   */
  subject: string;
};

/**
 * The request payload used to accept a consent request.
 */
export type AcceptOAuth2ConsentRequest = {
  context?: JsonRawMessage;
  grant_access_token_audience?: StringSliceJsonFormat;
  grant_scope?: StringSliceJsonFormat;
  handled_at?: NullTime;
  /**
   * Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
   * client asks the same user for the same, or a subset of, scope.
   */
  remember?: boolean;
  /**
   * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
   * authorization will be remembered indefinitely.
   */
  remember_for?: number;
  session?: AcceptOAuth2ConsentRequestSession;
};

export type ListOAuth2ClientsRequest = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Items per Page
     *
     * This is the number of items per page to return.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_size?: number;
    /**
     * Next Page Token
     *
     * The next page token.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_token?: string;
    /**
     * The name of the clients to filter by.
     */
    client_name?: string;
    /**
     * The owner of the clients to filter by.
     */
    owner?: string;
  };
  url: "/admin/clients";
};

export type ListOAuth2ClientsErrors = {
  /**
   * Default Error Response
   */
  default: ErrorOAuth2;
};

export type ListOAuth2ClientsError =
  ListOAuth2ClientsErrors[keyof ListOAuth2ClientsErrors];

export type ListOAuth2ClientsResponses = {
  /**
   * Paginated OAuth2 Client List Response
   */
  200: Array<OAuth2Client>;
};

export type ListOAuth2ClientsResponse =
  ListOAuth2ClientsResponses[keyof ListOAuth2ClientsResponses];

export type CreateOAuth2ClientRequest = {
  /**
   * OAuth 2.0 Client Request Body
   */
  body: OAuth2Client;
  path?: never;
  query?: never;
  url: "/admin/clients";
};

export type CreateOAuth2ClientErrors = {
  /**
   * Bad Request Error Response
   */
  400: ErrorOAuth2;
  /**
   * Default Error Response
   */
  default: ErrorOAuth2;
};

export type CreateOAuth2ClientError =
  CreateOAuth2ClientErrors[keyof CreateOAuth2ClientErrors];

export type CreateOAuth2ClientResponses = {
  /**
   * oAuth2Client
   */
  201: OAuth2Client;
};

export type CreateOAuth2ClientResponse =
  CreateOAuth2ClientResponses[keyof CreateOAuth2ClientResponses];

export type DeleteOAuth2ClientRequest = {
  body?: never;
  path: {
    /**
     * The id of the OAuth 2.0 Client.
     */
    id: string;
  };
  query?: never;
  url: "/admin/clients/{id}";
};

export type DeleteOAuth2ClientErrors = {
  /**
   * genericError
   */
  default: GenericError;
};

export type DeleteOAuth2ClientError =
  DeleteOAuth2ClientErrors[keyof DeleteOAuth2ClientErrors];

export type DeleteOAuth2ClientResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type DeleteOAuth2ClientResponse =
  DeleteOAuth2ClientResponses[keyof DeleteOAuth2ClientResponses];

export type GetOAuth2ClientRequest = {
  body?: never;
  path: {
    /**
     * The id of the OAuth 2.0 Client.
     */
    id: string;
  };
  query?: never;
  url: "/admin/clients/{id}";
};

export type GetOAuth2ClientErrors = {
  /**
   * Default Error Response
   */
  default: ErrorOAuth2;
};

export type GetOAuth2ClientError =
  GetOAuth2ClientErrors[keyof GetOAuth2ClientErrors];

export type GetOAuth2ClientResponses = {
  /**
   * oAuth2Client
   */
  200: OAuth2Client;
};

export type GetOAuth2ClientResponse =
  GetOAuth2ClientResponses[keyof GetOAuth2ClientResponses];

export type PatchOAuth2ClientRequest = {
  /**
   * OAuth 2.0 Client JSON Patch Body
   */
  body: JsonPatchDocument;
  path: {
    /**
     * The id of the OAuth 2.0 Client.
     */
    id: string;
  };
  query?: never;
  url: "/admin/clients/{id}";
};

export type PatchOAuth2ClientErrors = {
  /**
   * Not Found Error Response
   */
  404: ErrorOAuth2;
  /**
   * Default Error Response
   */
  default: ErrorOAuth2;
};

export type PatchOAuth2ClientError =
  PatchOAuth2ClientErrors[keyof PatchOAuth2ClientErrors];

export type PatchOAuth2ClientResponses = {
  /**
   * oAuth2Client
   */
  200: OAuth2Client;
};

export type PatchOAuth2ClientResponse =
  PatchOAuth2ClientResponses[keyof PatchOAuth2ClientResponses];

export type SetOAuth2ClientRequest = {
  /**
   * OAuth 2.0 Client Request Body
   */
  body: OAuth2Client;
  path: {
    /**
     * OAuth 2.0 Client ID
     */
    id: string;
  };
  query?: never;
  url: "/admin/clients/{id}";
};

export type SetOAuth2ClientErrors = {
  /**
   * Bad Request Error Response
   */
  400: ErrorOAuth2;
  /**
   * Not Found Error Response
   */
  404: ErrorOAuth2;
  /**
   * Default Error Response
   */
  default: ErrorOAuth2;
};

export type SetOAuth2ClientError =
  SetOAuth2ClientErrors[keyof SetOAuth2ClientErrors];

export type SetOAuth2ClientResponses = {
  /**
   * oAuth2Client
   */
  200: OAuth2Client;
};

export type SetOAuth2ClientResponse =
  SetOAuth2ClientResponses[keyof SetOAuth2ClientResponses];

export type SetOAuth2ClientLifespansRequest = {
  body?: OAuth2ClientTokenLifespans;
  path: {
    /**
     * OAuth 2.0 Client ID
     */
    id: string;
  };
  query?: never;
  url: "/admin/clients/{id}/lifespans";
};

export type SetOAuth2ClientLifespansErrors = {
  /**
   * genericError
   */
  default: GenericError;
};

export type SetOAuth2ClientLifespansError =
  SetOAuth2ClientLifespansErrors[keyof SetOAuth2ClientLifespansErrors];

export type SetOAuth2ClientLifespansResponses = {
  /**
   * oAuth2Client
   */
  200: OAuth2Client;
};

export type SetOAuth2ClientLifespansResponse =
  SetOAuth2ClientLifespansResponses[keyof SetOAuth2ClientLifespansResponses];

export type DeleteJsonWebKeySetRequest = {
  body?: never;
  path: {
    /**
     * The JSON Web Key Set
     */
    set: string;
  };
  query?: never;
  url: "/admin/keys/{set}";
};

export type DeleteJsonWebKeySetErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type DeleteJsonWebKeySetError =
  DeleteJsonWebKeySetErrors[keyof DeleteJsonWebKeySetErrors];

export type DeleteJsonWebKeySetResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type DeleteJsonWebKeySetResponse =
  DeleteJsonWebKeySetResponses[keyof DeleteJsonWebKeySetResponses];

export type GetJsonWebKeySetRequest = {
  body?: never;
  path: {
    /**
     * JSON Web Key Set ID
     */
    set: string;
  };
  query?: never;
  url: "/admin/keys/{set}";
};

export type GetJsonWebKeySetErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type GetJsonWebKeySetError =
  GetJsonWebKeySetErrors[keyof GetJsonWebKeySetErrors];

export type GetJsonWebKeySetResponses = {
  /**
   * jsonWebKeySet
   */
  200: JsonWebKeySet;
};

export type GetJsonWebKeySetResponse =
  GetJsonWebKeySetResponses[keyof GetJsonWebKeySetResponses];

export type CreateJsonWebKeySetRequest = {
  body: CreateJsonWebKeySet;
  path: {
    /**
     * The JSON Web Key Set ID
     */
    set: string;
  };
  query?: never;
  url: "/admin/keys/{set}";
};

export type CreateJsonWebKeySetErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type CreateJsonWebKeySetError =
  CreateJsonWebKeySetErrors[keyof CreateJsonWebKeySetErrors];

export type CreateJsonWebKeySetResponses = {
  /**
   * jsonWebKeySet
   */
  201: JsonWebKeySet;
};

export type CreateJsonWebKeySetResponse =
  CreateJsonWebKeySetResponses[keyof CreateJsonWebKeySetResponses];

export type SetJsonWebKeySetRequest = {
  body?: JsonWebKeySet;
  path: {
    /**
     * The JSON Web Key Set ID
     */
    set: string;
  };
  query?: never;
  url: "/admin/keys/{set}";
};

export type SetJsonWebKeySetErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type SetJsonWebKeySetError =
  SetJsonWebKeySetErrors[keyof SetJsonWebKeySetErrors];

export type SetJsonWebKeySetResponses = {
  /**
   * jsonWebKeySet
   */
  200: JsonWebKeySet;
};

export type SetJsonWebKeySetResponse =
  SetJsonWebKeySetResponses[keyof SetJsonWebKeySetResponses];

export type DeleteJsonWebKeyRequest = {
  body?: never;
  path: {
    /**
     * The JSON Web Key Set
     */
    set: string;
    /**
     * The JSON Web Key ID (kid)
     */
    kid: string;
  };
  query?: never;
  url: "/admin/keys/{set}/{kid}";
};

export type DeleteJsonWebKeyErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type DeleteJsonWebKeyError =
  DeleteJsonWebKeyErrors[keyof DeleteJsonWebKeyErrors];

export type DeleteJsonWebKeyResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type DeleteJsonWebKeyResponse =
  DeleteJsonWebKeyResponses[keyof DeleteJsonWebKeyResponses];

export type GetJsonWebKeyRequest = {
  body?: never;
  path: {
    /**
     * JSON Web Key Set ID
     */
    set: string;
    /**
     * JSON Web Key ID
     */
    kid: string;
  };
  query?: never;
  url: "/admin/keys/{set}/{kid}";
};

export type GetJsonWebKeyErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type GetJsonWebKeyError = GetJsonWebKeyErrors[keyof GetJsonWebKeyErrors];

export type GetJsonWebKeyResponses = {
  /**
   * jsonWebKeySet
   */
  200: JsonWebKeySet;
};

export type GetJsonWebKeyResponse =
  GetJsonWebKeyResponses[keyof GetJsonWebKeyResponses];

export type SetJsonWebKeyRequest = {
  body?: JsonWebKey;
  path: {
    /**
     * The JSON Web Key Set ID
     */
    set: string;
    /**
     * JSON Web Key ID
     */
    kid: string;
  };
  query?: never;
  url: "/admin/keys/{set}/{kid}";
};

export type SetJsonWebKeyErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type SetJsonWebKeyError = SetJsonWebKeyErrors[keyof SetJsonWebKeyErrors];

export type SetJsonWebKeyResponses = {
  /**
   * jsonWebKey
   */
  200: JsonWebKey;
};

export type SetJsonWebKeyResponse =
  SetJsonWebKeyResponses[keyof SetJsonWebKeyResponses];

export type GetOAuth2ConsentRequestRequest = {
  body?: never;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Consent Request Challenge
     */
    consent_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/consent";
};

export type GetOAuth2ConsentRequestErrors = {
  /**
   * oAuth2RedirectTo
   */
  410: OAuth2RedirectTo;
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type GetOAuth2ConsentRequestError =
  GetOAuth2ConsentRequestErrors[keyof GetOAuth2ConsentRequestErrors];

export type GetOAuth2ConsentRequestResponses = {
  /**
   * oAuth2ConsentRequest
   */
  200: OAuth2ConsentRequest;
};

export type GetOAuth2ConsentRequestResponse =
  GetOAuth2ConsentRequestResponses[keyof GetOAuth2ConsentRequestResponses];

export type AcceptOAuth2ConsentRequestRequest = {
  body?: AcceptOAuth2ConsentRequest;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Consent Request Challenge
     */
    consent_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/consent/accept";
};

export type AcceptOAuth2ConsentRequestErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type AcceptOAuth2ConsentRequestError =
  AcceptOAuth2ConsentRequestErrors[keyof AcceptOAuth2ConsentRequestErrors];

export type AcceptOAuth2ConsentRequestResponses = {
  /**
   * oAuth2RedirectTo
   */
  200: OAuth2RedirectTo;
};

export type AcceptOAuth2ConsentRequestResponse =
  AcceptOAuth2ConsentRequestResponses[keyof AcceptOAuth2ConsentRequestResponses];

export type RejectOAuth2ConsentRequestRequest = {
  body?: RejectOAuth2Request;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Consent Request Challenge
     */
    consent_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/consent/reject";
};

export type RejectOAuth2ConsentRequestErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type RejectOAuth2ConsentRequestError =
  RejectOAuth2ConsentRequestErrors[keyof RejectOAuth2ConsentRequestErrors];

export type RejectOAuth2ConsentRequestResponses = {
  /**
   * oAuth2RedirectTo
   */
  200: OAuth2RedirectTo;
};

export type RejectOAuth2ConsentRequestResponse =
  RejectOAuth2ConsentRequestResponses[keyof RejectOAuth2ConsentRequestResponses];

export type GetOAuth2LoginRequestRequest = {
  body?: never;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Login Request Challenge
     */
    login_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/login";
};

export type GetOAuth2LoginRequestErrors = {
  /**
   * oAuth2RedirectTo
   */
  410: OAuth2RedirectTo;
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type GetOAuth2LoginRequestError =
  GetOAuth2LoginRequestErrors[keyof GetOAuth2LoginRequestErrors];

export type GetOAuth2LoginRequestResponses = {
  /**
   * oAuth2LoginRequest
   */
  200: OAuth2LoginRequest;
};

export type GetOAuth2LoginRequestResponse =
  GetOAuth2LoginRequestResponses[keyof GetOAuth2LoginRequestResponses];

export type AcceptOAuth2LoginRequestRequest = {
  body?: AcceptOAuth2LoginRequest;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Login Request Challenge
     */
    login_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/login/accept";
};

export type AcceptOAuth2LoginRequestErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type AcceptOAuth2LoginRequestError =
  AcceptOAuth2LoginRequestErrors[keyof AcceptOAuth2LoginRequestErrors];

export type AcceptOAuth2LoginRequestResponses = {
  /**
   * oAuth2RedirectTo
   */
  200: OAuth2RedirectTo;
};

export type AcceptOAuth2LoginRequestResponse =
  AcceptOAuth2LoginRequestResponses[keyof AcceptOAuth2LoginRequestResponses];

export type RejectOAuth2LoginRequestRequest = {
  body?: RejectOAuth2Request;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Login Request Challenge
     */
    login_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/login/reject";
};

export type RejectOAuth2LoginRequestErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type RejectOAuth2LoginRequestError =
  RejectOAuth2LoginRequestErrors[keyof RejectOAuth2LoginRequestErrors];

export type RejectOAuth2LoginRequestResponses = {
  /**
   * oAuth2RedirectTo
   */
  200: OAuth2RedirectTo;
};

export type RejectOAuth2LoginRequestResponse =
  RejectOAuth2LoginRequestResponses[keyof RejectOAuth2LoginRequestResponses];

export type GetOAuth2LogoutRequestRequest = {
  body?: never;
  path?: never;
  query: {
    logout_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/logout";
};

export type GetOAuth2LogoutRequestErrors = {
  /**
   * oAuth2RedirectTo
   */
  410: OAuth2RedirectTo;
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type GetOAuth2LogoutRequestError =
  GetOAuth2LogoutRequestErrors[keyof GetOAuth2LogoutRequestErrors];

export type GetOAuth2LogoutRequestResponses = {
  /**
   * oAuth2LogoutRequest
   */
  200: OAuth2LogoutRequest;
};

export type GetOAuth2LogoutRequestResponse =
  GetOAuth2LogoutRequestResponses[keyof GetOAuth2LogoutRequestResponses];

export type AcceptOAuth2LogoutRequestRequest = {
  body?: never;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Logout Request Challenge
     */
    logout_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/logout/accept";
};

export type AcceptOAuth2LogoutRequestErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type AcceptOAuth2LogoutRequestError =
  AcceptOAuth2LogoutRequestErrors[keyof AcceptOAuth2LogoutRequestErrors];

export type AcceptOAuth2LogoutRequestResponses = {
  /**
   * oAuth2RedirectTo
   */
  200: OAuth2RedirectTo;
};

export type AcceptOAuth2LogoutRequestResponse =
  AcceptOAuth2LogoutRequestResponses[keyof AcceptOAuth2LogoutRequestResponses];

export type RejectOAuth2LogoutRequestRequest = {
  body?: never;
  path?: never;
  query: {
    logout_challenge: string;
  };
  url: "/admin/oauth2/auth/requests/logout/reject";
};

export type RejectOAuth2LogoutRequestErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type RejectOAuth2LogoutRequestError =
  RejectOAuth2LogoutRequestErrors[keyof RejectOAuth2LogoutRequestErrors];

export type RejectOAuth2LogoutRequestResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type RejectOAuth2LogoutRequestResponse =
  RejectOAuth2LogoutRequestResponses[keyof RejectOAuth2LogoutRequestResponses];

export type RevokeOAuth2ConsentSessionsRequest = {
  body?: never;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Consent Subject
     *
     * The subject whose consent sessions should be deleted.
     */
    subject: string;
    /**
     * OAuth 2.0 Client ID
     *
     * If set, deletes only those consent sessions that have been granted to the specified OAuth 2.0 Client ID.
     */
    client?: string;
    /**
     * Revoke All Consent Sessions
     *
     * If set to `true` deletes all consent sessions by the Subject that have been granted.
     */
    all?: boolean;
  };
  url: "/admin/oauth2/auth/sessions/consent";
};

export type RevokeOAuth2ConsentSessionsErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type RevokeOAuth2ConsentSessionsError =
  RevokeOAuth2ConsentSessionsErrors[keyof RevokeOAuth2ConsentSessionsErrors];

export type RevokeOAuth2ConsentSessionsResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type RevokeOAuth2ConsentSessionsResponse =
  RevokeOAuth2ConsentSessionsResponses[keyof RevokeOAuth2ConsentSessionsResponses];

export type ListOAuth2ConsentSessionsRequest = {
  body?: never;
  path?: never;
  query: {
    /**
     * Items per Page
     *
     * This is the number of items per page to return.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_size?: number;
    /**
     * Next Page Token
     *
     * The next page token.
     * For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     */
    page_token?: string;
    /**
     * The subject to list the consent sessions for.
     */
    subject: string;
    /**
     * The login session id to list the consent sessions for.
     */
    login_session_id?: string;
  };
  url: "/admin/oauth2/auth/sessions/consent";
};

export type ListOAuth2ConsentSessionsErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type ListOAuth2ConsentSessionsError =
  ListOAuth2ConsentSessionsErrors[keyof ListOAuth2ConsentSessionsErrors];

export type ListOAuth2ConsentSessionsResponses = {
  /**
   * oAuth2ConsentSessions
   */
  200: OAuth2ConsentSessions;
};

export type ListOAuth2ConsentSessionsResponse =
  ListOAuth2ConsentSessionsResponses[keyof ListOAuth2ConsentSessionsResponses];

export type RevokeOAuth2LoginSessionsRequest = {
  body?: never;
  path?: never;
  query?: {
    /**
     * OAuth 2.0 Subject
     *
     * The subject to revoke authentication sessions for.
     */
    subject?: string;
    /**
     * Login Session ID
     *
     * The login session to revoke.
     */
    sid?: string;
  };
  url: "/admin/oauth2/auth/sessions/login";
};

export type RevokeOAuth2LoginSessionsErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type RevokeOAuth2LoginSessionsError =
  RevokeOAuth2LoginSessionsErrors[keyof RevokeOAuth2LoginSessionsErrors];

export type RevokeOAuth2LoginSessionsResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type RevokeOAuth2LoginSessionsResponse =
  RevokeOAuth2LoginSessionsResponses[keyof RevokeOAuth2LoginSessionsResponses];

export type IntrospectOAuth2TokenRequest = {
  body?: {
    /**
     * An optional, space separated list of required scopes. If the access token was not granted one of the
     * scopes, the result of active will be false.
     */
    scope?: string;
    /**
     * The string value of the token. For access tokens, this
     * is the "access_token" value returned from the token endpoint
     * defined in OAuth 2.0. For refresh tokens, this is the "refresh_token"
     * value returned.
     */
    token: string;
  };
  path?: never;
  query?: never;
  url: "/admin/oauth2/introspect";
};

export type IntrospectOAuth2TokenErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type IntrospectOAuth2TokenError =
  IntrospectOAuth2TokenErrors[keyof IntrospectOAuth2TokenErrors];

export type IntrospectOAuth2TokenResponses = {
  /**
   * introspectedOAuth2Token
   */
  200: IntrospectedOAuth2Token;
};

export type IntrospectOAuth2TokenResponse =
  IntrospectOAuth2TokenResponses[keyof IntrospectOAuth2TokenResponses];

export type DeleteOAuth2TokenRequest = {
  body?: never;
  path?: never;
  query: {
    /**
     * OAuth 2.0 Client ID
     */
    client_id: string;
  };
  url: "/admin/oauth2/tokens";
};

export type DeleteOAuth2TokenErrors = {
  /**
   * errorOAuth2
   */
  default: ErrorOAuth2;
};

export type DeleteOAuth2TokenError =
  DeleteOAuth2TokenErrors[keyof DeleteOAuth2TokenErrors];

export type DeleteOAuth2TokenResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type DeleteOAuth2TokenResponse =
  DeleteOAuth2TokenResponses[keyof DeleteOAuth2TokenResponses];

export type ListTrustedOAuth2JwtGrantIssuersRequest = {
  body?: never;
  path?: never;
  query?: {
    MaxItems?: number;
    DefaultItems?: number;
    /**
     * If optional "issuer" is supplied, only jwt-bearer grants with this issuer will be returned.
     */
    issuer?: string;
  };
  url: "/admin/trust/grants/jwt-bearer/issuers";
};

export type ListTrustedOAuth2JwtGrantIssuersErrors = {
  /**
   * genericError
   */
  default: GenericError;
};

export type ListTrustedOAuth2JwtGrantIssuersError =
  ListTrustedOAuth2JwtGrantIssuersErrors[keyof ListTrustedOAuth2JwtGrantIssuersErrors];

export type ListTrustedOAuth2JwtGrantIssuersResponses = {
  /**
   * trustedOAuth2JwtGrantIssuers
   */
  200: TrustedOAuth2JwtGrantIssuers;
};

export type ListTrustedOAuth2JwtGrantIssuersResponse =
  ListTrustedOAuth2JwtGrantIssuersResponses[keyof ListTrustedOAuth2JwtGrantIssuersResponses];

export type TrustOAuth2JwtGrantIssuerRequest = {
  body?: TrustOAuth2JwtGrantIssuer;
  path?: never;
  query?: never;
  url: "/admin/trust/grants/jwt-bearer/issuers";
};

export type TrustOAuth2JwtGrantIssuerErrors = {
  /**
   * genericError
   */
  default: GenericError;
};

export type TrustOAuth2JwtGrantIssuerError =
  TrustOAuth2JwtGrantIssuerErrors[keyof TrustOAuth2JwtGrantIssuerErrors];

export type TrustOAuth2JwtGrantIssuerResponses = {
  /**
   * trustedOAuth2JwtGrantIssuer
   */
  201: TrustedOAuth2JwtGrantIssuer;
};

export type TrustOAuth2JwtGrantIssuerResponse =
  TrustOAuth2JwtGrantIssuerResponses[keyof TrustOAuth2JwtGrantIssuerResponses];

export type DeleteTrustedOAuth2JwtGrantIssuerRequest = {
  body?: never;
  path: {
    /**
     * The id of the desired grant
     */
    id: string;
  };
  query?: never;
  url: "/admin/trust/grants/jwt-bearer/issuers/{id}";
};

export type DeleteTrustedOAuth2JwtGrantIssuerErrors = {
  /**
   * genericError
   */
  default: GenericError;
};

export type DeleteTrustedOAuth2JwtGrantIssuerError =
  DeleteTrustedOAuth2JwtGrantIssuerErrors[keyof DeleteTrustedOAuth2JwtGrantIssuerErrors];

export type DeleteTrustedOAuth2JwtGrantIssuerResponses = {
  /**
   * Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
   * typically 204.
   */
  204: void;
};

export type DeleteTrustedOAuth2JwtGrantIssuerResponse =
  DeleteTrustedOAuth2JwtGrantIssuerResponses[keyof DeleteTrustedOAuth2JwtGrantIssuerResponses];

export type GetTrustedOAuth2JwtGrantIssuerRequest = {
  body?: never;
  path: {
    /**
     * The id of the desired grant
     */
    id: string;
  };
  query?: never;
  url: "/admin/trust/grants/jwt-bearer/issuers/{id}";
};

export type GetTrustedOAuth2JwtGrantIssuerErrors = {
  /**
   * genericError
   */
  default: GenericError;
};

export type GetTrustedOAuth2JwtGrantIssuerError =
  GetTrustedOAuth2JwtGrantIssuerErrors[keyof GetTrustedOAuth2JwtGrantIssuerErrors];

export type GetTrustedOAuth2JwtGrantIssuerResponses = {
  /**
   * trustedOAuth2JwtGrantIssuer
   */
  200: TrustedOAuth2JwtGrantIssuer;
};

export type GetTrustedOAuth2JwtGrantIssuerResponse =
  GetTrustedOAuth2JwtGrantIssuerResponses[keyof GetTrustedOAuth2JwtGrantIssuerResponses];

export type IsAliveRequest = {
  body?: never;
  path?: never;
  query?: never;
  url: "/health/alive";
};

export type IsAliveErrors = {
  /**
   * genericError
   */
  500: GenericError;
};

export type IsAliveError = IsAliveErrors[keyof IsAliveErrors];

export type IsAliveResponses = {
  /**
   * Ory Hydra is ready to accept connections.
   */
  200: HealthStatus;
};

export type IsAliveResponse = IsAliveResponses[keyof IsAliveResponses];

export type IsReadyRequest = {
  body?: never;
  path?: never;
  query?: never;
  url: "/health/ready";
};

export type IsReadyErrors = {
  /**
   * Ory Kratos is not yet ready to accept requests.
   */
  503: {
    /**
     * Errors contains a list of errors that caused the not ready status.
     */
    errors?: {
      [key: string]: string;
    };
  };
};

export type IsReadyError = IsReadyErrors[keyof IsReadyErrors];

export type IsReadyResponses = {
  /**
   * Ory Hydra is ready to accept requests.
   */
  200: {
    /**
     * Always "ok".
     */
    status?: string;
  };
};

export type IsReadyResponse = IsReadyResponses[keyof IsReadyResponses];

export type GetVersionRequest = {
  body?: never;
  path?: never;
  query?: never;
  url: "/version";
};

export type GetVersionResponses = {
  /**
   * Returns the Ory Hydra version.
   */
  200: {
    /**
     * The version of Ory Hydra.
     */
    version?: string;
  };
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];
