/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export type paths = {
  "/admin/clients": {
    delete?: never;
    /**
     * List OAuth 2.0 Clients
     * @description This endpoint lists all clients in the database, and never returns client secrets.
     *     As a default it lists the first 100 clients.
     */
    get: operations["listOAuth2Clients"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    /**
     * Create OAuth 2.0 Client
     * @description Create a new OAuth 2.0 client. If you pass `client_secret` the secret is used, otherwise a random secret
     *     is generated. The secret is echoed in the response. It is not possible to retrieve it later on.
     */
    post: operations["createOAuth2Client"];
    put?: never;
    trace?: never;
  };
  "/admin/clients/{id}": {
    /**
     * Delete OAuth 2.0 Client
     * @description Delete an existing OAuth 2.0 Client by its ID.
     *
     *     OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     *     Make sure that this endpoint is well protected and only callable by first-party components.
     */
    delete: operations["deleteOAuth2Client"];
    /**
     * Get an OAuth 2.0 Client
     * @description Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.
     *
     *     OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     */
    get: operations["getOAuth2Client"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    /**
     * Patch OAuth 2.0 Client
     * @description Patch an existing OAuth 2.0 Client using JSON Patch. If you pass `client_secret`
     *     the secret will be updated and returned via the API. This is the
     *     only time you will be able to retrieve the client secret, so write it down and keep it safe.
     *
     *     OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     */
    patch: operations["patchOAuth2Client"];
    post?: never;
    /**
     * Set OAuth 2.0 Client
     * @description Replaces an existing OAuth 2.0 Client with the payload you send. If you pass `client_secret` the secret is used,
     *     otherwise the existing secret is used.
     *
     *     If set, the secret is echoed in the response. It is not possible to retrieve it later on.
     *
     *     OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     */
    put: operations["setOAuth2Client"];
    trace?: never;
  };
  "/admin/clients/{id}/lifespans": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Set OAuth2 Client Token Lifespans
     * @description Set lifespans of different token types issued for this OAuth 2.0 client. Does not modify other fields.
     */
    put: operations["setOAuth2ClientLifespans"];
    trace?: never;
  };
  "/admin/keys/{set}": {
    /**
     * Delete JSON Web Key Set
     * @description Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.
     *
     *     A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     */
    delete: operations["deleteJsonWebKeySet"];
    /**
     * Retrieve a JSON Web Key Set
     * @description This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.
     *
     *     A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     */
    get: operations["getJsonWebKeySet"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    /**
     * Create JSON Web Key
     * @description This endpoint is capable of generating JSON Web Key Sets for you. There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.
     *
     *     A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     */
    post: operations["createJsonWebKeySet"];
    /**
     * Update a JSON Web Key Set
     * @description Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.
     *
     *     A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     */
    put: operations["setJsonWebKeySet"];
    trace?: never;
  };
  "/admin/keys/{set}/{kid}": {
    /**
     * Delete JSON Web Key
     * @description Use this endpoint to delete a single JSON Web Key.
     *
     *     A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A
     *     JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses
     *     this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens),
     *     and allows storing user-defined keys as well.
     */
    delete: operations["deleteJsonWebKey"];
    /**
     * Get JSON Web Key
     * @description This endpoint returns a singular JSON Web Key contained in a set. It is identified by the set and the specific key ID (kid).
     */
    get: operations["getJsonWebKey"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Set JSON Web Key
     * @description Use this method if you do not want to let Hydra generate the JWKs for you, but instead save your own.
     *
     *     A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     */
    put: operations["setJsonWebKey"];
    trace?: never;
  };
  "/admin/oauth2/auth/requests/consent": {
    delete?: never;
    /**
     * Get OAuth 2.0 Consent Request
     * @description When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
     *     to authenticate the subject and then tell Ory now about it. If the subject authenticated, he/she must now be asked if
     *     the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject's behalf.
     *
     *     The consent challenge is appended to the consent provider's URL to which the subject's user-agent (browser) is redirected to. The consent
     *     provider uses that challenge to fetch information on the OAuth2 request and then tells Ory if the subject accepted
     *     or rejected the request.
     *
     *     The default consent provider is available via the Ory Managed Account Experience. To customize the consent provider, please
     *     head over to the OAuth 2.0 documentation.
     */
    get: operations["getOAuth2ConsentRequest"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/admin/oauth2/auth/requests/consent/accept": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Accept OAuth 2.0 Consent Request
     * @description When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
     *     to authenticate the subject and then tell Ory now about it. If the subject authenticated, he/she must now be asked if
     *     the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject's behalf.
     *
     *     The consent challenge is appended to the consent provider's URL to which the subject's user-agent (browser) is redirected to. The consent
     *     provider uses that challenge to fetch information on the OAuth2 request and then tells Ory if the subject accepted
     *     or rejected the request.
     *
     *     This endpoint tells Ory that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf.
     *     The consent provider includes additional information, such as session data for access and ID tokens, and if the
     *     consent request should be used as basis for future requests.
     *
     *     The response contains a redirect URL which the consent provider should redirect the user-agent to.
     *
     *     The default consent provider is available via the Ory Managed Account Experience. To customize the consent provider, please
     *     head over to the OAuth 2.0 documentation.
     */
    put: operations["acceptOAuth2ConsentRequest"];
    trace?: never;
  };
  "/admin/oauth2/auth/requests/consent/reject": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Reject OAuth 2.0 Consent Request
     * @description When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
     *     to authenticate the subject and then tell Ory now about it. If the subject authenticated, he/she must now be asked if
     *     the OAuth 2.0 Client which initiated the flow should be allowed to access the resources on the subject's behalf.
     *
     *     The consent challenge is appended to the consent provider's URL to which the subject's user-agent (browser) is redirected to. The consent
     *     provider uses that challenge to fetch information on the OAuth2 request and then tells Ory if the subject accepted
     *     or rejected the request.
     *
     *     This endpoint tells Ory that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf.
     *     The consent provider must include a reason why the consent was not granted.
     *
     *     The response contains a redirect URL which the consent provider should redirect the user-agent to.
     *
     *     The default consent provider is available via the Ory Managed Account Experience. To customize the consent provider, please
     *     head over to the OAuth 2.0 documentation.
     */
    put: operations["rejectOAuth2ConsentRequest"];
    trace?: never;
  };
  "/admin/oauth2/auth/requests/login": {
    delete?: never;
    /**
     * Get OAuth 2.0 Login Request
     * @description When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
     *     to authenticate the subject and then tell the Ory OAuth2 Service about it.
     *
     *     Per default, the login provider is Ory itself. You may use a different login provider which needs to be a web-app
     *     you write and host, and it must be able to authenticate ("show the subject a login screen")
     *     a subject (in OAuth2 the proper name for subject is "resource owner").
     *
     *     The authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login
     *     provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
     */
    get: operations["getOAuth2LoginRequest"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/admin/oauth2/auth/requests/login/accept": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Accept OAuth 2.0 Login Request
     * @description When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
     *     to authenticate the subject and then tell the Ory OAuth2 Service about it.
     *
     *     The authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login
     *     provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
     *
     *     This endpoint tells Ory that the subject has successfully authenticated and includes additional information such as
     *     the subject's ID and if Ory should remember the subject's subject agent for future authentication attempts by setting
     *     a cookie.
     *
     *     The response contains a redirect URL which the login provider should redirect the user-agent to.
     */
    put: operations["acceptOAuth2LoginRequest"];
    trace?: never;
  };
  "/admin/oauth2/auth/requests/login/reject": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Reject OAuth 2.0 Login Request
     * @description When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, Ory asks the login provider
     *     to authenticate the subject and then tell the Ory OAuth2 Service about it.
     *
     *     The authentication challenge is appended to the login provider URL to which the subject's user-agent (browser) is redirected to. The login
     *     provider uses that challenge to fetch information on the OAuth2 request and then accept or reject the requested authentication process.
     *
     *     This endpoint tells Ory that the subject has not authenticated and includes a reason why the authentication
     *     was denied.
     *
     *     The response contains a redirect URL which the login provider should redirect the user-agent to.
     */
    put: operations["rejectOAuth2LoginRequest"];
    trace?: never;
  };
  "/admin/oauth2/auth/requests/logout": {
    delete?: never;
    /**
     * Get OAuth 2.0 Session Logout Request
     * @description Use this endpoint to fetch an Ory OAuth 2.0 logout request.
     */
    get: operations["getOAuth2LogoutRequest"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/admin/oauth2/auth/requests/logout/accept": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Accept OAuth 2.0 Session Logout Request
     * @description When a user or an application requests Ory OAuth 2.0 to remove the session state of a subject, this endpoint is used to confirm that logout request.
     *
     *     The response contains a redirect URL which the consent provider should redirect the user-agent to.
     */
    put: operations["acceptOAuth2LogoutRequest"];
    trace?: never;
  };
  "/admin/oauth2/auth/requests/logout/reject": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Reject OAuth 2.0 Session Logout Request
     * @description When a user or an application requests Ory OAuth 2.0 to remove the session state of a subject, this endpoint is used to deny that logout request.
     *     No HTTP request body is required.
     *
     *     The response is empty as the logout provider has to chose what action to perform next.
     */
    put: operations["rejectOAuth2LogoutRequest"];
    trace?: never;
  };
  "/admin/oauth2/auth/sessions/consent": {
    /**
     * Revoke OAuth 2.0 Consent Sessions of a Subject
     * @description This endpoint revokes a subject's granted consent sessions and invalidates all
     *     associated OAuth 2.0 Access Tokens. You may also only revoke sessions for a specific OAuth 2.0 Client ID.
     */
    delete: operations["revokeOAuth2ConsentSessions"];
    /**
     * List OAuth 2.0 Consent Sessions of a Subject
     * @description This endpoint lists all subject's granted consent sessions, including client and granted scope.
     *     If the subject is unknown or has not granted any consent sessions yet, the endpoint returns an
     *     empty JSON array with status code 200 OK.
     */
    get: operations["listOAuth2ConsentSessions"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/admin/oauth2/auth/sessions/login": {
    /**
     * Revokes OAuth 2.0 Login Sessions by either a Subject or a SessionID
     * @description This endpoint invalidates authentication sessions. After revoking the authentication session(s), the subject
     *     has to re-authenticate at the Ory OAuth2 Provider. This endpoint does not invalidate any tokens.
     *
     *     If you send the subject in a query param, all authentication sessions that belong to that subject are revoked.
     *     No OpenID Connect Front- or Back-channel logout is performed in this case.
     *
     *     Alternatively, you can send a SessionID via `sid` query param, in which case, only the session that is connected
     *     to that SessionID is revoked. OpenID Connect Back-channel logout is performed in this case.
     */
    delete: operations["revokeOAuth2LoginSessions"];
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/admin/oauth2/introspect": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    /**
     * Introspect OAuth2 Access and Refresh Tokens
     * @description The introspection endpoint allows to check if a token (both refresh and access) is active or not. An active token
     *     is neither expired nor revoked. If a token is active, additional information on the token will be included. You can
     *     set additional data for a token by setting `session.access_token` during the consent flow.
     */
    post: operations["introspectOAuth2Token"];
    put?: never;
    trace?: never;
  };
  "/admin/oauth2/tokens": {
    /**
     * Delete OAuth 2.0 Access Tokens from specific OAuth 2.0 Client
     * @description This endpoint deletes OAuth2 access tokens issued to an OAuth 2.0 Client from the database.
     */
    delete: operations["deleteOAuth2Token"];
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/admin/trust/grants/jwt-bearer/issuers": {
    delete?: never;
    /**
     * List Trusted OAuth2 JWT Bearer Grant Type Issuers
     * @description Use this endpoint to list all trusted JWT Bearer Grant Type Issuers.
     */
    get: operations["listTrustedOAuth2JwtGrantIssuers"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    /**
     * Trust OAuth2 JWT Bearer Grant Type Issuer
     * @description Use this endpoint to establish a trust relationship for a JWT issuer
     *     to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication
     *     and Authorization Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
     */
    post: operations["trustOAuth2JwtGrantIssuer"];
    put?: never;
    trace?: never;
  };
  "/admin/trust/grants/jwt-bearer/issuers/{id}": {
    /**
     * Delete Trusted OAuth2 JWT Bearer Grant Type Issuer
     * @description Use this endpoint to delete trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you
     *     created the trust relationship.
     *
     *     Once deleted, the associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile
     *     for OAuth 2.0 Client Authentication and Authorization Grant.
     */
    delete: operations["deleteTrustedOAuth2JwtGrantIssuer"];
    /**
     * Get Trusted OAuth2 JWT Bearer Grant Type Issuer
     * @description Use this endpoint to get a trusted JWT Bearer Grant Type Issuer. The ID is the one returned when you
     *     created the trust relationship.
     */
    get: operations["getTrustedOAuth2JwtGrantIssuer"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/credentials": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    /**
     * Issues a Verifiable Credential
     * @description This endpoint creates a verifiable credential that attests that the user
     *     authenticated with the provided access token owns a certain public/private key
     *     pair.
     *
     *     More information can be found at
     *     https://openid.net/specs/openid-connect-userinfo-vc-1_0.html.
     */
    post: operations["createVerifiableCredential"];
    put?: never;
    trace?: never;
  };
  "/health/alive": {
    delete?: never;
    /**
     * Check HTTP Server Status
     * @description This endpoint returns a HTTP 200 status code when Ory Hydra is accepting incoming
     *     HTTP requests. This status does currently not include checks whether the database connection is working.
     *
     *     If the service supports TLS Edge Termination, this endpoint does not require the
     *     `X-Forwarded-Proto` header to be set.
     *
     *     Be aware that if you are running multiple nodes of this service, the health status will never
     *     refer to the cluster state, only to a single instance.
     */
    get: operations["isAlive"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/health/ready": {
    delete?: never;
    /**
     * Check HTTP Server and Database Status
     * @description This endpoint returns a HTTP 200 status code when Ory Hydra is up running and the environment dependencies (e.g.
     *     the database) are responsive as well.
     *
     *     If the service supports TLS Edge Termination, this endpoint does not require the
     *     `X-Forwarded-Proto` header to be set.
     *
     *     Be aware that if you are running multiple nodes of Ory Hydra, the health status will never
     *     refer to the cluster state, only to a single instance.
     */
    get: operations["isReady"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
  "/oauth2/register": {
    delete?: never;
    get?: never;
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    /**
     * Register OAuth2 Client using OpenID Dynamic Client Registration
     * @description This endpoint behaves like the administrative counterpart (`createOAuth2Client`) but is capable of facing the
     *     public internet directly and can be used in self-service. It implements the OpenID Connect
     *     Dynamic Client Registration Protocol. This feature needs to be enabled in the configuration. This endpoint
     *     is disabled by default. It can be enabled by an administrator.
     *
     *     Please note that using this endpoint you are not able to choose the `client_secret` nor the `client_id` as those
     *     values will be server generated when specifying `token_endpoint_auth_method` as `client_secret_basic` or
     *     `client_secret_post`.
     *
     *     The `client_secret` will be returned in the response and you will not be able to retrieve it later on.
     *     Write the secret down and keep it somewhere safe.
     */
    post: operations["createOidcDynamicClient"];
    put?: never;
    trace?: never;
  };
  "/oauth2/register/{id}": {
    /**
     * Delete OAuth 2.0 Client using the OpenID Dynamic Client Registration Management Protocol
     * @description This endpoint behaves like the administrative counterpart (`deleteOAuth2Client`) but is capable of facing the
     *     public internet directly and can be used in self-service. It implements the OpenID Connect
     *     Dynamic Client Registration Protocol. This feature needs to be enabled in the configuration. This endpoint
     *     is disabled by default. It can be enabled by an administrator.
     *
     *     To use this endpoint, you will need to present the client's authentication credentials. If the OAuth2 Client
     *     uses the Token Endpoint Authentication Method `client_secret_post`, you need to present the client secret in the URL query.
     *     If it uses `client_secret_basic`, present the Client ID and the Client Secret in the Authorization header.
     *
     *     OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     */
    delete: operations["deleteOidcDynamicClient"];
    /**
     * Get OAuth2 Client using OpenID Dynamic Client Registration
     * @description This endpoint behaves like the administrative counterpart (`getOAuth2Client`) but is capable of facing the
     *     public internet directly and can be used in self-service. It implements the OpenID Connect
     *     Dynamic Client Registration Protocol.
     *
     *     To use this endpoint, you will need to present the client's authentication credentials. If the OAuth2 Client
     *     uses the Token Endpoint Authentication Method `client_secret_post`, you need to present the client secret in the URL query.
     *     If it uses `client_secret_basic`, present the Client ID and the Client Secret in the Authorization header.
     */
    get: operations["getOidcDynamicClient"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    /**
     * Set OAuth2 Client using OpenID Dynamic Client Registration
     * @description This endpoint behaves like the administrative counterpart (`setOAuth2Client`) but is capable of facing the
     *     public internet directly to be used by third parties. It implements the OpenID Connect
     *     Dynamic Client Registration Protocol.
     *
     *     This feature is disabled per default. It can be enabled by a system administrator.
     *
     *     If you pass `client_secret` the secret is used, otherwise the existing secret is used. If set, the secret is echoed in the response.
     *     It is not possible to retrieve it later on.
     *
     *     To use this endpoint, you will need to present the client's authentication credentials. If the OAuth2 Client
     *     uses the Token Endpoint Authentication Method `client_secret_post`, you need to present the client secret in the URL query.
     *     If it uses `client_secret_basic`, present the Client ID and the Client Secret in the Authorization header.
     *
     *     OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     */
    put: operations["setOidcDynamicClient"];
    trace?: never;
  };
  "/version": {
    delete?: never;
    /**
     * Return Running Software Version.
     * @description This endpoint returns the version of Ory Hydra.
     *
     *     If the service supports TLS Edge Termination, this endpoint does not require the
     *     `X-Forwarded-Proto` header to be set.
     *
     *     Be aware that if you are running multiple nodes of this service, the version will never
     *     refer to the cluster state, only to a single instance.
     */
    get: operations["getVersion"];
    head?: never;
    options?: never;
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    patch?: never;
    post?: never;
    put?: never;
    trace?: never;
  };
};
export type webhooks = { [key: string]: never };
export type components = {
  headers: never;
  parameters: never;
  pathItems: never;
  requestBodies: never;
  responses: {
    /** @description Empty responses are sent when, for example, resources are deleted. The HTTP status code for empty responses is
     *     typically 204. */
    emptyResponse: {
      content?: never;
      headers: {
        [name: string]: unknown;
      };
    };
    /** @description Bad Request Error Response */
    errorOAuth2BadRequest: {
      content: {
        "application/json": components["schemas"]["errorOAuth2"];
      };
      headers: {
        [name: string]: unknown;
      };
    };
    /** @description Default Error Response */
    errorOAuth2Default: {
      content: {
        "application/json": components["schemas"]["errorOAuth2"];
      };
      headers: {
        [name: string]: unknown;
      };
    };
    /** @description Not Found Error Response */
    errorOAuth2NotFound: {
      content: {
        "application/json": components["schemas"]["errorOAuth2"];
      };
      headers: {
        [name: string]: unknown;
      };
    };
    /** @description Paginated OAuth2 Client List Response */
    listOAuth2Clients: {
      content: {
        "application/json": components["schemas"]["oAuth2Client"][];
      };
      headers: {
        [name: string]: unknown;
      };
    };
  };
  schemas: {
    /** The request payload used to accept a consent request. */
    acceptOAuth2ConsentRequest: {
      context?: components["schemas"]["JSONRawMessage"];
      grant_access_token_audience?: components["schemas"]["StringSliceJSONFormat"];
      grant_scope?: components["schemas"]["StringSliceJSONFormat"];
      handled_at?: components["schemas"]["nullTime"];
      /** @description Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
       *     client asks the same user for the same, or a subset of, scope. */
      remember?: boolean;
      /**
       * Format: int64
       * @description RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
       *     authorization will be remembered indefinitely.
       */
      remember_for?: number;
      session?: components["schemas"]["acceptOAuth2ConsentRequestSession"];
    };
    /** Pass session data to a consent request. */
    acceptOAuth2ConsentRequestSession: {
      /** @description AccessToken sets session data for the access and refresh token, as well as any future tokens issued by the
       *     refresh grant. Keep in mind that this data will be available to anyone performing OAuth 2.0 Challenge Introspection.
       *     If only your services can perform OAuth 2.0 Challenge Introspection, this is usually fine. But if third parties
       *     can access that endpoint as well, sensitive data from the session might be exposed to them. Use with care! */
      access_token?: unknown;
      /** @description IDToken sets session data for the OpenID Connect ID token. Keep in mind that the session'id payloads are readable
       *     by anyone that has access to the ID Challenge. Use with care! */
      id_token?: unknown;
    };
    /** HandledLoginRequest is the request payload used to accept a login request. */
    acceptOAuth2LoginRequest: {
      /** @description ACR sets the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
       *     to express that, for example, a user authenticated using two factor authentication. */
      acr?: string;
      amr?: components["schemas"]["StringSliceJSONFormat"];
      context?: components["schemas"]["JSONRawMessage"];
      /** @description Extend OAuth2 authentication session lifespan
       *
       *     If set to `true`, the OAuth2 authentication cookie lifespan is extended. This is for example useful if you want the user to be able to use `prompt=none` continuously.
       *
       *     This value can only be set to `true` if the user has an authentication, which is the case if the `skip` value is `true`. */
      extend_session_lifespan?: boolean;
      /** @description ForceSubjectIdentifier forces the "pairwise" user ID of the end-user that authenticated. The "pairwise" user ID refers to the
       *     (Pairwise Identifier Algorithm)[http://openid.net/specs/openid-connect-core-1_0.html#PairwiseAlg] of the OpenID
       *     Connect specification. It allows you to set an obfuscated subject ("user") identifier that is unique to the client.
       *
       *     Please note that this changes the user ID on endpoint /userinfo and sub claim of the ID Token. It does not change the
       *     sub claim in the OAuth 2.0 Introspection.
       *
       *     Per default, ORY Hydra handles this value with its own algorithm. In case you want to set this yourself
       *     you can use this field. Please note that setting this field has no effect if `pairwise` is not configured in
       *     ORY Hydra or the OAuth 2.0 Client does not expect a pairwise identifier (set via `subject_type` key in the client's
       *     configuration).
       *
       *     Please also be aware that ORY Hydra is unable to properly compute this value during authentication. This implies
       *     that you have to compute this value on every authentication process (probably depending on the client ID or some
       *     other unique value).
       *
       *     If you fail to compute the proper value, then authentication processes which have id_token_hint set might fail. */
      force_subject_identifier?: string;
      /** @description IdentityProviderSessionID is the session ID of the end-user that authenticated.
       *     If specified, we will use this value to propagate the logout. */
      identity_provider_session_id?: string;
      /** @description Remember, if set to true, tells ORY Hydra to remember this user by telling the user agent (browser) to store
       *     a cookie with authentication data. If the same user performs another OAuth 2.0 Authorization Request, he/she
       *     will not be asked to log in again. */
      remember?: boolean;
      /**
       * Format: int64
       * @description RememberFor sets how long the authentication should be remembered for in seconds. If set to `0`, the
       *     authorization will be remembered for the duration of the browser session (using a session cookie).
       */
      remember_for?: number;
      /** @description Subject is the user ID of the end-user that authenticated. */
      subject: string;
    };
    /** @description Create JSON Web Key Set Request Body */
    createJsonWebKeySet: {
      /** @description JSON Web Key Algorithm
       *
       *     The algorithm to be used for creating the key. Supports `RS256`, `ES256`, `ES512`, `HS512`, and `HS256`. */
      alg: string;
      /** @description JSON Web Key ID
       *
       *     The Key ID of the key to be created. */
      kid: string;
      /** @description JSON Web Key Use
       *
       *     The "use" (public key use) parameter identifies the intended use of
       *     the public key. The "use" parameter is employed to indicate whether
       *     a public key is used for encrypting data or verifying the signature
       *     on data. Valid values are "enc" and "sig". */
      use: string;
    };
    /** CreateVerifiableCredentialRequestBody contains the request body to request a verifiable credential. */
    CreateVerifiableCredentialRequestBody: {
      format?: string;
      proof?: components["schemas"]["VerifiableCredentialProof"];
      types?: string[];
    };
    /** @description Error */
    errorOAuth2: {
      /** @description Error */
      error?: string;
      /** @description Error Debug Information
       *
       *     Only available in dev mode. */
      error_debug?: string;
      /** @description Error Description */
      error_description?: string;
      /**
       * @description Error Hint
       *
       *     Helps the user identify the error cause.
       * @example The redirect URL is not allowed.
       */
      error_hint?: string;
      /**
       * Format: int64
       * @description HTTP Status Code
       * @example 401
       */
      status_code?: number;
    };
    genericError: {
      /**
       * Format: int64
       * @description The status code
       * @example 404
       */
      code?: number;
      /**
       * @description Debug information
       *
       *     This field is often not exposed to protect against leaking
       *     sensitive information.
       * @example SQL field "foo" is not a bool.
       */
      debug?: string;
      /** @description Further error details */
      details?: unknown;
      /** @description The error ID
       *
       *     Useful when trying to identify various errors in application logic. */
      id?: string;
      /**
       * @description Error message
       *
       *     The error's message.
       * @example The resource could not be found
       */
      message: string;
      /**
       * @description A human-readable reason for the error
       * @example User with ID 1234 does not exist.
       */
      reason?: string;
      /**
       * @description The request ID
       *
       *     The request ID is often exposed internally in order to trace
       *     errors across service architectures. This is often a UUID.
       * @example d7ef54b1-ec15-46e6-bccb-524b82c035e6
       */
      request?: string;
      /**
       * @description The status description
       * @example Not Found
       */
      status?: string;
    };
    /** The health status of the service. */
    healthStatus: {
      /** @description Status always contains "ok". */
      status?: string;
    };
    /** @description Introspection contains an access token's session data as specified by
     *     [IETF RFC 7662](https://tools.ietf.org/html/rfc7662) */
    introspectedOAuth2Token: {
      /** @description Active is a boolean indicator of whether or not the presented token
       *     is currently active.  The specifics of a token's "active" state
       *     will vary depending on the implementation of the authorization
       *     server and the information it keeps about its tokens, but a "true"
       *     value return for the "active" property will generally indicate
       *     that a given token has been issued by this authorization server,
       *     has not been revoked by the resource owner, and is within its
       *     given time window of validity (e.g., after its issuance time and
       *     before its expiration time). */
      active: boolean;
      /** @description Audience contains a list of the token's intended audiences. */
      aud?: string[];
      /** @description ID is aclient identifier for the OAuth 2.0 client that
       *     requested this token. */
      client_id?: string;
      /**
       * Format: int64
       * @description Expires at is an integer timestamp, measured in the number of seconds
       *     since January 1 1970 UTC, indicating when this token will expire.
       */
      exp?: number;
      /** @description Extra is arbitrary data set by the session. */
      ext?: {
        [key: string]: unknown;
      };
      /**
       * Format: int64
       * @description Issued at is an integer timestamp, measured in the number of seconds
       *     since January 1 1970 UTC, indicating when this token was
       *     originally issued.
       */
      iat?: number;
      /** @description IssuerURL is a string representing the issuer of this token */
      iss?: string;
      /**
       * Format: int64
       * @description NotBefore is an integer timestamp, measured in the number of seconds
       *     since January 1 1970 UTC, indicating when this token is not to be
       *     used before.
       */
      nbf?: number;
      /** @description ObfuscatedSubject is set when the subject identifier algorithm was set to "pairwise" during authorization.
       *     It is the `sub` value of the ID Token that was issued. */
      obfuscated_subject?: string;
      /** @description Scope is a JSON string containing a space-separated list of
       *     scopes associated with this token. */
      scope?: string;
      /** @description Subject of the token, as defined in JWT [RFC7519].
       *     Usually a machine-readable identifier of the resource owner who
       *     authorized this token. */
      sub?: string;
      /** @description TokenType is the introspected token's type, typically `Bearer`. */
      token_type?: string;
      /** @description TokenUse is the introspected token's use, for example `access_token` or `refresh_token`. */
      token_use?: string;
      /** @description Username is a human-readable identifier for the resource owner who
       *     authorized this token. */
      username?: string;
    };
    /** @description A JSONPatch document as defined by RFC 6902 */
    jsonPatch: {
      /**
       * @description This field is used together with operation "move" and uses JSON Pointer notation.
       *
       *     Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
       * @example /name
       */
      from?: string;
      /**
       * @description The operation to be performed. One of "add", "remove", "replace", "move", "copy", or "test".
       * @example replace
       */
      op: string;
      /**
       * @description The path to the target path. Uses JSON pointer notation.
       *
       *     Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
       * @example /name
       */
      path: string;
      /**
       * @description The value to be used within the operations.
       *
       *     Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
       * @example foobar
       */
      value?: unknown;
    };
    /** @description A JSONPatchDocument request */
    jsonPatchDocument: components["schemas"]["jsonPatch"][];
    /** JSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger. */
    JSONRawMessage: unknown;
    jsonWebKey: {
      /**
       * @description The "alg" (algorithm) parameter identifies the algorithm intended for
       *     use with the key.  The values used should either be registered in the
       *     IANA "JSON Web Signature and Encryption Algorithms" registry
       *     established by [JWA] or be a value that contains a Collision-
       *     Resistant Name.
       * @example RS256
       */
      alg: string;
      /** @example P-256 */
      crv?: string;
      /** @example T_N8I-6He3M8a7X1vWt6TGIx4xB_GP3Mb4SsZSA4v-orvJzzRiQhLlRR81naWYxfQAYt5isDI6_C2L9bdWo4FFPjGQFvNoRX-_sBJyBI_rl-TBgsZYoUlAj3J92WmY2inbA-PwyJfsaIIDceYBC-eX-xiCu6qMqkZi3MwQAFL6bMdPEM0z4JBcwFT3VdiWAIRUuACWQwrXMq672x7fMuaIaHi7XDGgt1ith23CLfaREmJku9PQcchbt_uEY-hqrFY6ntTtS4paWWQj86xLL94S-Tf6v6xkL918PfLSOTq6XCzxvlFwzBJqApnAhbwqLjpPhgUG04EDRrqrSBc5Y1BLevn6Ip5h1AhessBp3wLkQgz_roeckt-ybvzKTjESMuagnpqLvOT7Y9veIug2MwPJZI2VjczRc1vzMs25XrFQ8DpUy-bNdp89TmvAXwctUMiJdgHloJw23Cv03gIUAkDnsTqZmkpbIf-crpgNKFmQP_EDKoe8p_PXZZgfbRri3NoEVGP7Mk6yEu8LjJhClhZaBNjuWw2-KlBfOA3g79mhfBnkInee5KO9mGR50qPk1V-MorUYNTFMZIm0kFE6eYVWFBwJHLKYhHU34DoiK1VP-svZpC2uAMFNA_UJEwM9CQ2b8qe4-5e9aywMvwcuArRkAB5mBIfOaOJao3mfukKAE */
      d?: string;
      /** @example G4sPXkc6Ya9y8oJW9_ILj4xuppu0lzi_H7VTkS8xj5SdX3coE0oimYwxIi2emTAue0UOa5dpgFGyBJ4c8tQ2VF402XRugKDTP8akYhFo5tAA77Qe_NmtuYZc3C3m3I24G2GvR5sSDxUyAN2zq8Lfn9EUms6rY3Ob8YeiKkTiBj0 */
      dp?: string;
      /** @example s9lAH9fggBsoFR8Oac2R_E2gw282rT2kGOAhvIllETE1efrA6huUUvMfBcMpn8lqeW6vzznYY5SSQF7pMdC_agI3nG8Ibp1BUb0JUiraRNqUfLhcQb_d9GF4Dh7e74WbRsobRonujTYN1xCaP6TO61jvWrX-L18txXw494Q_cgk */
      dq?: string;
      /** @example AQAB */
      e?: string;
      /** @example GawgguFyGrWKav7AX4VKUg */
      k?: string;
      /**
       * @description The "kid" (key ID) parameter is used to match a specific key.  This
       *     is used, for instance, to choose among a set of keys within a JWK Set
       *     during key rollover.  The structure of the "kid" value is
       *     unspecified.  When "kid" values are used within a JWK Set, different
       *     keys within the JWK Set SHOULD use distinct "kid" values.  (One
       *     example in which different keys might use the same "kid" value is if
       *     they have different "kty" (key type) values but are considered to be
       *     equivalent alternatives by the application using them.)  The "kid"
       *     value is a case-sensitive string.
       * @example 1603dfe0af8f4596
       */
      kid: string;
      /**
       * @description The "kty" (key type) parameter identifies the cryptographic algorithm
       *     family used with the key, such as "RSA" or "EC". "kty" values should
       *     either be registered in the IANA "JSON Web Key Types" registry
       *     established by [JWA] or be a value that contains a Collision-
       *     Resistant Name.  The "kty" value is a case-sensitive string.
       * @example RSA
       */
      kty: string;
      /** @example vTqrxUyQPl_20aqf5kXHwDZrel-KovIp8s7ewJod2EXHl8tWlRB3_Rem34KwBfqlKQGp1nqah-51H4Jzruqe0cFP58hPEIt6WqrvnmJCXxnNuIB53iX_uUUXXHDHBeaPCSRoNJzNysjoJ30TIUsKBiirhBa7f235PXbKiHducLevV6PcKxJ5cY8zO286qJLBWSPm-OIevwqsIsSIH44Qtm9sioFikhkbLwoqwWORGAY0nl6XvVOlhADdLjBSqSAeT1FPuCDCnXwzCDR8N9IFB_IjdStFkC-rVt2K5BYfPd0c3yFp_vHR15eRd0zJ8XQ7woBC8Vnsac6Et1pKS59pX6256DPWu8UDdEOolKAPgcd_g2NpA76cAaF_jcT80j9KrEzw8Tv0nJBGesuCjPNjGs_KzdkWTUXt23Hn9QJsdc1MZuaW0iqXBepHYfYoqNelzVte117t4BwVp0kUM6we0IqyXClaZgOI8S-WDBw2_Ovdm8e5NmhYAblEVoygcX8Y46oH6bKiaCQfKCFDMcRgChme7AoE1yZZYsPbaG_3IjPrC4LBMHQw8rM9dWjJ8ImjicvZ1pAm0dx-KHCP3y5PVKrxBDf1zSOsBRkOSjB8TPODnJMz6-jd5hTtZxpZPwPoIdCanTZ3ZD6uRBpTmDwtpRGm63UQs1m5FWPwb0T2IF0 */
      n?: string;
      /** @example 6NbkXwDWUhi-eR55Cgbf27FkQDDWIamOaDr0rj1q0f1fFEz1W5A_09YvG09Fiv1AO2-D8Rl8gS1Vkz2i0zCSqnyy8A025XOcRviOMK7nIxE4OH_PEsko8dtIrb3TmE2hUXvCkmzw9EsTF1LQBOGC6iusLTXepIC1x9ukCKFZQvdgtEObQ5kzd9Nhq-cdqmSeMVLoxPLd1blviVT9Vm8-y12CtYpeJHOaIDtVPLlBhJiBoPKWg3vxSm4XxIliNOefqegIlsmTIa3MpS6WWlCK3yHhat0Q-rRxDxdyiVdG_wzJvp0Iw_2wms7pe-PgNPYvUWH9JphWP5K38YqEBiJFXQ */
      p?: string;
      /** @example 0A1FmpOWR91_RAWpqreWSavNaZb9nXeKiBo0DQGBz32DbqKqQ8S4aBJmbRhJcctjCLjain-ivut477tAUMmzJwVJDDq2MZFwC9Q-4VYZmFU4HJityQuSzHYe64RjN-E_NQ02TWhG3QGW6roq6c57c99rrUsETwJJiwS8M5p15Miuz53DaOjv-uqqFAFfywN5WkxHbraBcjHtMiQuyQbQqkCFh-oanHkwYNeytsNhTu2mQmwR5DR2roZ2nPiFjC6nsdk-A7E3S3wMzYYFw7jvbWWoYWo9vB40_MY2Y0FYQSqcDzcBIcq_0tnnasf3VW4Fdx6m80RzOb2Fsnln7vKXAQ */
      q?: string;
      /** @example GyM_p6JrXySiz1toFgKbWV-JdI3jQ4ypu9rbMWx3rQJBfmt0FoYzgUIZEVFEcOqwemRN81zoDAaa-Bk0KWNGDjJHZDdDmFhW3AN7lI-puxk_mHZGJ11rxyR8O55XLSe3SPmRfKwZI6yU24ZxvQKFYItdldUKGzO6Ia6zTKhAVRU */
      qi?: string;
      /**
       * @description Use ("public key use") identifies the intended use of
       *     the public key. The "use" parameter is employed to indicate whether
       *     a public key is used for encrypting data or verifying the signature
       *     on data. Values are commonly "sig" (signature) or "enc" (encryption).
       * @example sig
       */
      use: string;
      /** @example f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU */
      x?: string;
      /** @description The "x5c" (X.509 certificate chain) parameter contains a chain of one
       *     or more PKIX certificates [RFC5280].  The certificate chain is
       *     represented as a JSON array of certificate value strings.  Each
       *     string in the array is a base64-encoded (Section 4 of [RFC4648] --
       *     not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value.
       *     The PKIX certificate containing the key value MUST be the first
       *     certificate. */
      x5c?: string[];
      /** @example x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0 */
      y?: string;
    };
    /** @description JSON Web Key Set */
    jsonWebKeySet: {
      /** @description List of JSON Web Keys
       *
       *     The value of the "keys" parameter is an array of JSON Web Key (JWK)
       *     values. By default, the order of the JWK values within the array does
       *     not imply an order of preference among them, although applications
       *     of JWK Sets can choose to assign a meaning to the order for their
       *     purposes, if desired. */
      keys?: components["schemas"]["jsonWebKey"][];
    };
    /**
     * Time duration
     * @description Specify a time duration in milliseconds, seconds, minutes, hours.
     */
    NullDuration: string;
    /**
     * NullTime implements sql.NullTime functionality.
     * Format: date-time
     */
    nullTime: string;
    /**
     * OAuth 2.0 Client
     * @description OAuth 2.0 Clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are
     *     generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     */
    oAuth2Client: {
      /** @description OAuth 2.0 Access Token Strategy
       *
       *     AccessTokenStrategy is the strategy used to generate access tokens.
       *     Valid options are `jwt` and `opaque`. `jwt` is a bad idea, see https://www.ory.sh/docs/hydra/advanced#json-web-tokens
       *     Setting the stragegy here overrides the global setting in `strategies.access_token`. */
      access_token_strategy?: string;
      allowed_cors_origins?: components["schemas"]["StringSliceJSONFormat"];
      audience?: components["schemas"]["StringSliceJSONFormat"];
      authorization_code_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      authorization_code_grant_id_token_lifespan?: components["schemas"]["NullDuration"];
      authorization_code_grant_refresh_token_lifespan?: components["schemas"]["NullDuration"];
      /** @description OpenID Connect Back-Channel Logout Session Required
       *
       *     Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout
       *     Token to identify the RP session with the OP when the backchannel_logout_uri is used.
       *     If omitted, the default value is false. */
      backchannel_logout_session_required?: boolean;
      /** @description OpenID Connect Back-Channel Logout URI
       *
       *     RP URL that will cause the RP to log itself out when sent a Logout Token by the OP. */
      backchannel_logout_uri?: string;
      client_credentials_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      /** @description OAuth 2.0 Client ID
       *
       *     The ID is immutable. If no ID is provided, a UUID4 will be generated. */
      client_id?: string;
      /** @description OAuth 2.0 Client Name
       *
       *     The human-readable name of the client to be presented to the
       *     end-user during authorization. */
      client_name?: string;
      /** @description OAuth 2.0 Client Secret
       *
       *     The secret will be included in the create request as cleartext, and then
       *     never again. The secret is kept in hashed format and is not recoverable once lost. */
      client_secret?: string;
      /**
       * Format: int64
       * @description OAuth 2.0 Client Secret Expires At
       *
       *     The field is currently not supported and its value is always 0.
       */
      client_secret_expires_at?: number;
      /** @description OAuth 2.0 Client URI
       *
       *     ClientURI is a URL string of a web page providing information about the client.
       *     If present, the server SHOULD display this URL to the end-user in
       *     a clickable fashion. */
      client_uri?: string;
      contacts?: components["schemas"]["StringSliceJSONFormat"];
      /**
       * Format: date-time
       * @description OAuth 2.0 Client Creation Date
       *
       *     CreatedAt returns the timestamp of the client's creation.
       */
      created_at?: string;
      /** @description OpenID Connect Front-Channel Logout Session Required
       *
       *     Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be
       *     included to identify the RP session with the OP when the frontchannel_logout_uri is used.
       *     If omitted, the default value is false. */
      frontchannel_logout_session_required?: boolean;
      /** @description OpenID Connect Front-Channel Logout URI
       *
       *     RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query
       *     parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the
       *     request and to determine which of the potentially multiple sessions is to be logged out; if either is
       *     included, both MUST be. */
      frontchannel_logout_uri?: string;
      grant_types?: components["schemas"]["StringSliceJSONFormat"];
      implicit_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      implicit_grant_id_token_lifespan?: components["schemas"]["NullDuration"];
      /** @description OAuth 2.0 Client JSON Web Key Set
       *
       *     Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as
       *     the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter
       *     is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for
       *     instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client
       *     can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation
       *     (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks
       *     parameters MUST NOT be used together. */
      jwks?: unknown;
      /** @description OAuth 2.0 Client JSON Web Key Set URL
       *
       *     URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains
       *     the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the
       *     Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing
       *     and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced
       *     JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both
       *     signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used
       *     to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST
       *     match those in the certificate. */
      jwks_uri?: string;
      jwt_bearer_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      /** @description OAuth 2.0 Client Logo URI
       *
       *     A URL string referencing the client's logo. */
      logo_uri?: string;
      metadata?: components["schemas"]["JSONRawMessage"];
      /** @description OAuth 2.0 Client Owner
       *
       *     Owner is a string identifying the owner of the OAuth 2.0 Client. */
      owner?: string;
      /** @description OAuth 2.0 Client Policy URI
       *
       *     PolicyURI is a URL string that points to a human-readable privacy policy document
       *     that describes how the deployment organization collects, uses,
       *     retains, and discloses personal data. */
      policy_uri?: string;
      post_logout_redirect_uris?: components["schemas"]["StringSliceJSONFormat"];
      redirect_uris?: components["schemas"]["StringSliceJSONFormat"];
      refresh_token_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      refresh_token_grant_id_token_lifespan?: components["schemas"]["NullDuration"];
      refresh_token_grant_refresh_token_lifespan?: components["schemas"]["NullDuration"];
      /** @description OpenID Connect Dynamic Client Registration Access Token
       *
       *     RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client
       *     using Dynamic Client Registration. */
      registration_access_token?: string;
      /** @description OpenID Connect Dynamic Client Registration URL
       *
       *     RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client. */
      registration_client_uri?: string;
      /** @description OpenID Connect Request Object Signing Algorithm
       *
       *     JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects
       *     from this Client MUST be rejected, if not signed with this algorithm. */
      request_object_signing_alg?: string;
      request_uris?: components["schemas"]["StringSliceJSONFormat"];
      response_types?: components["schemas"]["StringSliceJSONFormat"];
      /**
       * @description OAuth 2.0 Client Scope
       *
       *     Scope is a string containing a space-separated list of scope values (as
       *     described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client
       *     can use when requesting access tokens.
       * @example scope1 scope-2 scope.3 scope:4
       */
      scope?: string;
      /** @description OpenID Connect Sector Identifier URI
       *
       *     URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a
       *     file with a single JSON array of redirect_uri values. */
      sector_identifier_uri?: string;
      /** @description SkipConsent skips the consent screen for this client. This field can only
       *     be set from the admin API. */
      skip_consent?: boolean;
      /** @description SkipLogoutConsent skips the logout consent screen for this client. This field can only
       *     be set from the admin API. */
      skip_logout_consent?: boolean;
      /** @description OpenID Connect Subject Type
       *
       *     The `subject_types_supported` Discovery parameter contains a
       *     list of the supported subject_type values for this server. Valid types include `pairwise` and `public`. */
      subject_type?: string;
      /**
       * @description OAuth 2.0 Token Endpoint Authentication Method
       *
       *     Requested Client Authentication method for the Token Endpoint. The options are:
       *
       *     `client_secret_basic`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header.
       *     `client_secret_post`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body.
       *     `private_key_jwt`: Use JSON Web Tokens to authenticate the client.
       *     `none`: Used for public clients (native apps, mobile apps) which can not have secrets.
       * @default client_secret_basic
       */
      token_endpoint_auth_method: string;
      /** @description OAuth 2.0 Token Endpoint Signing Algorithm
       *
       *     Requested Client Authentication signing algorithm for the Token Endpoint. */
      token_endpoint_auth_signing_alg?: string;
      /** @description OAuth 2.0 Client Terms of Service URI
       *
       *     A URL string pointing to a human-readable terms of service
       *     document for the client that describes a contractual relationship
       *     between the end-user and the client that the end-user accepts when
       *     authorizing the client. */
      tos_uri?: string;
      /**
       * Format: date-time
       * @description OAuth 2.0 Client Last Update Date
       *
       *     UpdatedAt returns the timestamp of the last update.
       */
      updated_at?: string;
      /** @description OpenID Connect Request Userinfo Signed Response Algorithm
       *
       *     JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT
       *     [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims
       *     as a UTF-8 encoded JSON object using the application/json content-type. */
      userinfo_signed_response_alg?: string;
    };
    /**
     * OAuth 2.0 Client Token Lifespans
     * @description Lifespans of different token types issued for this OAuth 2.0 Client.
     */
    oAuth2ClientTokenLifespans: {
      authorization_code_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      authorization_code_grant_id_token_lifespan?: components["schemas"]["NullDuration"];
      authorization_code_grant_refresh_token_lifespan?: components["schemas"]["NullDuration"];
      client_credentials_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      implicit_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      implicit_grant_id_token_lifespan?: components["schemas"]["NullDuration"];
      jwt_bearer_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      refresh_token_grant_access_token_lifespan?: components["schemas"]["NullDuration"];
      refresh_token_grant_id_token_lifespan?: components["schemas"]["NullDuration"];
      refresh_token_grant_refresh_token_lifespan?: components["schemas"]["NullDuration"];
    };
    /** Contains information on an ongoing consent request. */
    oAuth2ConsentRequest: {
      /** @description ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session. You can use it
       *     to express that, for example, a user authenticated using two factor authentication. */
      acr?: string;
      amr?: components["schemas"]["StringSliceJSONFormat"];
      /** @description ID is the identifier ("authorization challenge") of the consent authorization request. It is used to
       *     identify the session. */
      challenge: string;
      client?: components["schemas"]["oAuth2Client"];
      context?: components["schemas"]["JSONRawMessage"];
      /** @description LoginChallenge is the login challenge this consent challenge belongs to. It can be used to associate
       *     a login and consent request in the login & consent app. */
      login_challenge?: string;
      /** @description LoginSessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag)
       *     this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false)
       *     this will be a new random value. This value is used as the "sid" parameter in the ID Token and in OIDC Front-/Back-
       *     channel logout. It's value can generally be used to associate consecutive login requests by a certain user. */
      login_session_id?: string;
      oidc_context?: components["schemas"]["oAuth2ConsentRequestOpenIDConnectContext"];
      /** @description RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
       *     initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
       *     might come in handy if you want to deal with additional request parameters. */
      request_url?: string;
      requested_access_token_audience?: components["schemas"]["StringSliceJSONFormat"];
      requested_scope?: components["schemas"]["StringSliceJSONFormat"];
      /** @description Skip, if true, implies that the client has requested the same scopes from the same user previously.
       *     If true, you must not ask the user to grant the requested scopes. You must however either allow or deny the
       *     consent request using the usual API call. */
      skip?: boolean;
      /** @description Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope
       *     requested by the OAuth 2.0 client. */
      subject?: string;
    };
    /** Contains optional information about the OpenID Connect request. */
    oAuth2ConsentRequestOpenIDConnectContext: {
      /** @description ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request.
       *     It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.
       *
       *     OpenID Connect defines it as follows:
       *     > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values
       *     that the Authorization Server is being requested to use for processing this Authentication Request, with the
       *     values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication
       *     performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a
       *     Voluntary Claim by this parameter. */
      acr_values?: string[];
      /** @description Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User.
       *     The defined values are:
       *     page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode.
       *     popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over.
       *     touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface.
       *     wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a "feature phone" type display.
       *
       *     The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display. */
      display?: string;
      /** @description IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the
       *     End-User's current or past authenticated session with the Client. */
      id_token_hint_claims?: {
        [key: string]: unknown;
      };
      /** @description LoginHint hints about the login identifier the End-User might use to log in (if necessary).
       *     This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier)
       *     and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a
       *     phone number in the format specified for the phone_number Claim. The use of this parameter is optional. */
      login_hint?: string;
      /** @description UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a
       *     space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value
       *     "fr-CA fr en" represents a preference for French as spoken in Canada, then French (without a region designation),
       *     followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested
       *     locales are not supported by the OpenID Provider. */
      ui_locales?: string[];
    };
    /**
     * OAuth 2.0 Consent Session
     * @description A completed OAuth 2.0 Consent Session.
     */
    oAuth2ConsentSession: {
      consent_request?: components["schemas"]["oAuth2ConsentRequest"];
      context?: components["schemas"]["JSONRawMessage"];
      expires_at?: {
        /** Format: date-time */
        access_token?: string;
        /** Format: date-time */
        authorize_code?: string;
        /** Format: date-time */
        id_token?: string;
        /** Format: date-time */
        par_context?: string;
        /** Format: date-time */
        refresh_token?: string;
      };
      grant_access_token_audience?: components["schemas"]["StringSliceJSONFormat"];
      grant_scope?: components["schemas"]["StringSliceJSONFormat"];
      handled_at?: components["schemas"]["nullTime"];
      /** @description Remember Consent
       *
       *     Remember, if set to true, tells ORY Hydra to remember this consent authorization and reuse it if the same
       *     client asks the same user for the same, or a subset of, scope. */
      remember?: boolean;
      /**
       * Format: int64
       * @description Remember Consent For
       *
       *     RememberFor sets how long the consent authorization should be remembered for in seconds. If set to `0`, the
       *     authorization will be remembered indefinitely.
       */
      remember_for?: number;
      session?: components["schemas"]["acceptOAuth2ConsentRequestSession"];
    };
    /** @description List of OAuth 2.0 Consent Sessions */
    oAuth2ConsentSessions: components["schemas"]["oAuth2ConsentSession"][];
    /** Contains information on an ongoing login request. */
    oAuth2LoginRequest: {
      /** @description ID is the identifier ("login challenge") of the login request. It is used to
       *     identify the session. */
      challenge: string;
      client: components["schemas"]["oAuth2Client"];
      oidc_context?: components["schemas"]["oAuth2ConsentRequestOpenIDConnectContext"];
      /** @description RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which
       *     initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but
       *     might come in handy if you want to deal with additional request parameters. */
      request_url: string;
      requested_access_token_audience?: components["schemas"]["StringSliceJSONFormat"];
      requested_scope?: components["schemas"]["StringSliceJSONFormat"];
      /** @description SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag)
       *     this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false)
       *     this will be a new random value. This value is used as the "sid" parameter in the ID Token and in OIDC Front-/Back-
       *     channel logout. It's value can generally be used to associate consecutive login requests by a certain user. */
      session_id?: string;
      /** @description Skip, if true, implies that the client has requested the same scopes from the same user previously.
       *     If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.
       *
       *     This feature allows you to update / set session information. */
      skip: boolean;
      /** @description Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope
       *     requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type
       *     when accepting the login request, or the request will fail. */
      subject: string;
    };
    /** Contains information about an ongoing logout request. */
    oAuth2LogoutRequest: {
      /** @description Challenge is the identifier ("logout challenge") of the logout authentication request. It is used to
       *     identify the session. */
      challenge?: string;
      client?: components["schemas"]["oAuth2Client"];
      /** @description RequestURL is the original Logout URL requested. */
      request_url?: string;
      /** @description RPInitiated is set to true if the request was initiated by a Relying Party (RP), also known as an OAuth 2.0 Client. */
      rp_initiated?: boolean;
      /** @description SessionID is the login session ID that was requested to log out. */
      sid?: string;
      /** @description Subject is the user for whom the logout was request. */
      subject?: string;
    };
    /**
     * OAuth 2.0 Redirect Browser To
     * @description Contains a redirect URL used to complete a login, consent, or logout request.
     */
    oAuth2RedirectTo: {
      /** @description RedirectURL is the URL which you should redirect the user's browser to once the authentication process is completed. */
      redirect_to: string;
    };
    pagination: {
      /**
       * Format: int64
       * @description Items per page
       *
       *     This is the number of items per page to return.
       *     For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
       * @default 250
       */
      page_size: number;
      /**
       * @description Next Page Token
       *
       *     The next page token.
       *     For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
       * @default 1
       */
      page_token: string;
    };
    /** The request payload used to accept a login or consent request. */
    rejectOAuth2Request: {
      /** @description The error should follow the OAuth2 error format (e.g. `invalid_request`, `login_required`).
       *
       *     Defaults to `request_denied`. */
      error?: string;
      /** @description Debug contains information to help resolve the problem as a developer. Usually not exposed
       *     to the public but only in the server logs. */
      error_debug?: string;
      /** @description Description of the error in a human readable format. */
      error_description?: string;
      /** @description Hint to help resolve the error. */
      error_hint?: string;
      /**
       * Format: int64
       * @description Represents the HTTP status code of the error (e.g. 401 or 403)
       *
       *     Defaults to 400
       */
      status_code?: number;
    };
    /** StringSliceJSONFormat represents []string{} which is encoded to/from JSON for SQL storage. */
    StringSliceJSONFormat: string[];
    /** @description OAuth2 JWT Bearer Grant Type Issuer Trust Relationship */
    trustedOAuth2JwtGrantIssuer: {
      /** @description The "allow_any_subject" indicates that the issuer is allowed to have any principal as the subject of the JWT. */
      allow_any_subject?: boolean;
      /**
       * Format: date-time
       * @description The "created_at" indicates, when grant was created.
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description The "expires_at" indicates, when grant will expire, so we will reject assertion from "issuer" targeting "subject".
       */
      expires_at?: string;
      /** @example 9edc811f-4e28-453c-9b46-4de65f00217f */
      id?: string;
      /**
       * @description The "issuer" identifies the principal that issued the JWT assertion (same as "iss" claim in JWT).
       * @example https://jwt-idp.example.com
       */
      issuer?: string;
      public_key?: components["schemas"]["trustedOAuth2JwtGrantJsonWebKey"];
      /**
       * @description The "scope" contains list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749])
       * @example [
       *       "openid",
       *       "offline"
       *     ]
       */
      scope?: string[];
      /**
       * @description The "subject" identifies the principal that is the subject of the JWT.
       * @example mike@example.com
       */
      subject?: string;
    };
    /** @description OAuth2 JWT Bearer Grant Type Issuer Trust Relationships */
    trustedOAuth2JwtGrantIssuers: components["schemas"]["trustedOAuth2JwtGrantIssuer"][];
    /** @description OAuth2 JWT Bearer Grant Type Issuer Trusted JSON Web Key */
    trustedOAuth2JwtGrantJsonWebKey: {
      /**
       * @description The "key_id" is key unique identifier (same as kid header in jws/jwt).
       * @example 123e4567-e89b-12d3-a456-426655440000
       */
      kid?: string;
      /**
       * @description The "set" is basically a name for a group(set) of keys. Will be the same as "issuer" in grant.
       * @example https://jwt-idp.example.com
       */
      set?: string;
    };
    /** @description Trust OAuth2 JWT Bearer Grant Type Issuer Request Body */
    trustOAuth2JwtGrantIssuer: {
      /** @description The "allow_any_subject" indicates that the issuer is allowed to have any principal as the subject of the JWT. */
      allow_any_subject?: boolean;
      /**
       * Format: date-time
       * @description The "expires_at" indicates, when grant will expire, so we will reject assertion from "issuer" targeting "subject".
       */
      expires_at: string;
      /**
       * @description The "issuer" identifies the principal that issued the JWT assertion (same as "iss" claim in JWT).
       * @example https://jwt-idp.example.com
       */
      issuer: string;
      jwk: components["schemas"]["jsonWebKey"];
      /**
       * @description The "scope" contains list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749])
       * @example [
       *       "openid",
       *       "offline"
       *     ]
       */
      scope: string[];
      /**
       * @description The "subject" identifies the principal that is the subject of the JWT.
       * @example mike@example.com
       */
      subject?: string;
    };
    /** VerifiableCredentialPrimingResponse contains the nonce to include in the proof-of-possession JWT. */
    verifiableCredentialPrimingResponse: {
      c_nonce?: string;
      /** Format: int64 */
      c_nonce_expires_in?: number;
      error?: string;
      error_debug?: string;
      error_description?: string;
      error_hint?: string;
      format?: string;
      /** Format: int64 */
      status_code?: number;
    };
    /** VerifiableCredentialProof contains the proof of a verifiable credential. */
    VerifiableCredentialProof: {
      jwt?: string;
      proof_type?: string;
    };
    /** VerifiableCredentialResponse contains the verifiable credential. */
    verifiableCredentialResponse: {
      credential_draft_00?: string;
      format?: string;
    };
    version: {
      /** @description Version is the service's version. */
      version?: string;
    };
  };
};
export type $defs = { [key: string]: never };
export type operations = {
  acceptOAuth2ConsentRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Consent Request Challenge */
        consent_challenge: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["acceptOAuth2ConsentRequest"];
      };
    };
    responses: {
      /** @description oAuth2RedirectTo */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  acceptOAuth2LoginRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Login Request Challenge */
        login_challenge: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["acceptOAuth2LoginRequest"];
      };
    };
    responses: {
      /** @description oAuth2RedirectTo */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  acceptOAuth2LogoutRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Logout Request Challenge */
        logout_challenge: string;
      };
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2RedirectTo */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  createJsonWebKeySet: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The JSON Web Key Set ID */
        set: string;
      };
      query?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["createJsonWebKeySet"];
      };
    };
    responses: {
      /** @description jsonWebKeySet */
      201: {
        content: {
          "application/json": components["schemas"]["jsonWebKeySet"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  createOAuth2Client: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    /** @description OAuth 2.0 Client Request Body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["oAuth2Client"];
      };
    };
    responses: {
      /** @description oAuth2Client */
      201: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      400: components["responses"]["errorOAuth2BadRequest"];
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  createOidcDynamicClient: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    /** @description Dynamic Client Registration Request Body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["oAuth2Client"];
      };
    };
    responses: {
      /** @description oAuth2Client */
      201: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      400: components["responses"]["errorOAuth2BadRequest"];
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  createVerifiableCredential: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateVerifiableCredentialRequestBody"];
      };
    };
    responses: {
      /** @description verifiableCredentialResponse */
      200: {
        content: {
          "application/json": components["schemas"]["verifiableCredentialResponse"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description verifiableCredentialPrimingResponse */
      400: {
        content: {
          "application/json": components["schemas"]["verifiableCredentialPrimingResponse"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  deleteJsonWebKey: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The JSON Web Key ID (kid) */
        kid: string;
        /** @description The JSON Web Key Set */
        set: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  deleteJsonWebKeySet: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The JSON Web Key Set */
        set: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  deleteOAuth2Client: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the OAuth 2.0 Client. */
        id: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  deleteOAuth2Token: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Client ID */
        client_id: string;
      };
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  deleteOidcDynamicClient: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the OAuth 2.0 Client. */
        id: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  deleteTrustedOAuth2JwtGrantIssuer: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the desired grant */
        id: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getJsonWebKey: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description JSON Web Key ID */
        kid: string;
        /** @description JSON Web Key Set ID */
        set: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description jsonWebKeySet */
      200: {
        content: {
          "application/json": components["schemas"]["jsonWebKeySet"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getJsonWebKeySet: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description JSON Web Key Set ID */
        set: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description jsonWebKeySet */
      200: {
        content: {
          "application/json": components["schemas"]["jsonWebKeySet"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getOAuth2Client: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the OAuth 2.0 Client. */
        id: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2Client */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  getOAuth2ConsentRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Consent Request Challenge */
        consent_challenge: string;
      };
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2ConsentRequest */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2ConsentRequest"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description oAuth2RedirectTo */
      410: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getOAuth2LoginRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Login Request Challenge */
        login_challenge: string;
      };
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2LoginRequest */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2LoginRequest"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description oAuth2RedirectTo */
      410: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getOAuth2LogoutRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        logout_challenge: string;
      };
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2LogoutRequest */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2LogoutRequest"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description oAuth2RedirectTo */
      410: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getOidcDynamicClient: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the OAuth 2.0 Client. */
        id: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2Client */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  getTrustedOAuth2JwtGrantIssuer: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the desired grant */
        id: string;
      };
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description trustedOAuth2JwtGrantIssuer */
      200: {
        content: {
          "application/json": components["schemas"]["trustedOAuth2JwtGrantIssuer"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  getVersion: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns the Ory Hydra version. */
      200: {
        content: {
          "application/json": {
            /** @description The version of Ory Hydra. */
            version?: string;
          };
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  introspectOAuth2Token: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    requestBody?: {
      content: {
        "application/x-www-form-urlencoded": {
          /** @description An optional, space separated list of required scopes. If the access token was not granted one of the
           *     scopes, the result of active will be false. */
          scope?: string;
          /** @description The string value of the token. For access tokens, this
           *     is the "access_token" value returned from the token endpoint
           *     defined in OAuth 2.0. For refresh tokens, this is the "refresh_token"
           *     value returned. */
          token: string;
        };
      };
    };
    responses: {
      /** @description introspectedOAuth2Token */
      200: {
        content: {
          "application/json": components["schemas"]["introspectedOAuth2Token"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  isAlive: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Ory Hydra is ready to accept connections. */
      200: {
        content: {
          "application/json": components["schemas"]["healthStatus"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description genericError */
      500: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  isReady: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Ory Hydra is ready to accept requests. */
      200: {
        content: {
          "application/json": {
            /** @description Always "ok". */
            status?: string;
          };
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description Ory Kratos is not yet ready to accept requests. */
      503: {
        content: {
          "application/json": {
            /** @description Errors contains a list of errors that caused the not ready status. */
            errors?: {
              [key: string]: string;
            };
          };
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  listOAuth2Clients: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: {
        /** @description The name of the clients to filter by. */
        client_name?: string;
        /** @description The owner of the clients to filter by. */
        owner?: string;
        /** @description Items per Page
         *
         *     This is the number of items per page to return.
         *     For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). */
        page_size?: number;
        /** @description Next Page Token
         *
         *     The next page token.
         *     For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). */
        page_token?: string;
      };
    };
    requestBody?: never;
    responses: {
      200: components["responses"]["listOAuth2Clients"];
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  listOAuth2ConsentSessions: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description The login session id to list the consent sessions for. */
        login_session_id?: string;
        /** @description Items per Page
         *
         *     This is the number of items per page to return.
         *     For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). */
        page_size?: number;
        /** @description Next Page Token
         *
         *     The next page token.
         *     For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). */
        page_token?: string;
        /** @description The subject to list the consent sessions for. */
        subject: string;
      };
    };
    requestBody?: never;
    responses: {
      /** @description oAuth2ConsentSessions */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2ConsentSessions"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  listTrustedOAuth2JwtGrantIssuers: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: {
        DefaultItems?: number;
        /** @description If optional "issuer" is supplied, only jwt-bearer grants with this issuer will be returned. */
        issuer?: string;
        MaxItems?: number;
      };
    };
    requestBody?: never;
    responses: {
      /** @description trustedOAuth2JwtGrantIssuers */
      200: {
        content: {
          "application/json": components["schemas"]["trustedOAuth2JwtGrantIssuers"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  patchOAuth2Client: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The id of the OAuth 2.0 Client. */
        id: string;
      };
      query?: never;
    };
    /** @description OAuth 2.0 Client JSON Patch Body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["jsonPatchDocument"];
      };
    };
    responses: {
      /** @description oAuth2Client */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      404: components["responses"]["errorOAuth2NotFound"];
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  rejectOAuth2ConsentRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Consent Request Challenge */
        consent_challenge: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["rejectOAuth2Request"];
      };
    };
    responses: {
      /** @description oAuth2RedirectTo */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  rejectOAuth2LoginRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description OAuth 2.0 Login Request Challenge */
        login_challenge: string;
      };
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["rejectOAuth2Request"];
      };
    };
    responses: {
      /** @description oAuth2RedirectTo */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2RedirectTo"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  rejectOAuth2LogoutRequest: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        logout_challenge: string;
      };
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  revokeOAuth2ConsentSessions: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query: {
        /** @description Revoke All Consent Sessions
         *
         *     If set to `true` deletes all consent sessions by the Subject that have been granted. */
        all?: boolean;
        /** @description OAuth 2.0 Client ID
         *
         *     If set, deletes only those consent sessions that have been granted to the specified OAuth 2.0 Client ID. */
        client?: string;
        /** @description OAuth 2.0 Consent Subject
         *
         *     The subject whose consent sessions should be deleted. */
        subject: string;
      };
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  revokeOAuth2LoginSessions: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: {
        /** @description Login Session ID
         *
         *     The login session to revoke. */
        sid?: string;
        /** @description OAuth 2.0 Subject
         *
         *     The subject to revoke authentication sessions for. */
        subject?: string;
      };
    };
    requestBody?: never;
    responses: {
      204: components["responses"]["emptyResponse"];
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  setJsonWebKey: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description JSON Web Key ID */
        kid: string;
        /** @description The JSON Web Key Set ID */
        set: string;
      };
      query?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["jsonWebKey"];
      };
    };
    responses: {
      /** @description jsonWebKey */
      200: {
        content: {
          "application/json": components["schemas"]["jsonWebKey"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  setJsonWebKeySet: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description The JSON Web Key Set ID */
        set: string;
      };
      query?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["jsonWebKeySet"];
      };
    };
    responses: {
      /** @description jsonWebKeySet */
      200: {
        content: {
          "application/json": components["schemas"]["jsonWebKeySet"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description errorOAuth2 */
      default: {
        content: {
          "application/json": components["schemas"]["errorOAuth2"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  setOAuth2Client: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description OAuth 2.0 Client ID */
        id: string;
      };
      query?: never;
    };
    /** @description OAuth 2.0 Client Request Body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["oAuth2Client"];
      };
    };
    responses: {
      /** @description oAuth2Client */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      400: components["responses"]["errorOAuth2BadRequest"];
      404: components["responses"]["errorOAuth2NotFound"];
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  setOAuth2ClientLifespans: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description OAuth 2.0 Client ID */
        id: string;
      };
      query?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["oAuth2ClientTokenLifespans"];
      };
    };
    responses: {
      /** @description oAuth2Client */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
  setOidcDynamicClient: {
    parameters: {
      cookie?: never;
      header?: never;
      path: {
        /** @description OAuth 2.0 Client ID */
        id: string;
      };
      query?: never;
    };
    /** @description OAuth 2.0 Client Request Body */
    requestBody: {
      content: {
        "application/json": components["schemas"]["oAuth2Client"];
      };
    };
    responses: {
      /** @description oAuth2Client */
      200: {
        content: {
          "application/json": components["schemas"]["oAuth2Client"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      404: components["responses"]["errorOAuth2NotFound"];
      default: components["responses"]["errorOAuth2Default"];
    };
  };
  trustOAuth2JwtGrantIssuer: {
    parameters: {
      cookie?: never;
      header?: never;
      path?: never;
      query?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["trustOAuth2JwtGrantIssuer"];
      };
    };
    responses: {
      /** @description trustedOAuth2JwtGrantIssuer */
      201: {
        content: {
          "application/json": components["schemas"]["trustedOAuth2JwtGrantIssuer"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
      /** @description genericError */
      default: {
        content: {
          "application/json": components["schemas"]["genericError"];
        };
        headers: {
          [name: string]: unknown;
        };
      };
    };
  };
};
